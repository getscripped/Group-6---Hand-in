{"version":3,"sources":["D:/370/FinalFrontend/node_modules/@angular/material/fesm2015/bottom-sheet.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAuXC,0wBAoBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAiFD;;;;;;;;;;;;;;;;;;;0BAaC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2XD,iSAGC;;;;;;;;;;;;;;;;;;;;;;;;kCAS8U","file":"bottom-sheet.js","sourcesContent":["import { OverlayModule, OverlayConfig, Overlay } from '@angular/cdk/overlay';\r\nimport { BasePortalOutlet, CdkPortalOutlet, PortalModule, TemplatePortal, ComponentPortal, PortalInjector } from '@angular/cdk/portal';\r\nimport { DOCUMENT, CommonModule, Location } from '@angular/common';\r\nimport { InjectionToken, EventEmitter, Component, ChangeDetectionStrategy, ViewEncapsulation, ElementRef, ChangeDetectorRef, Optional, Inject, ViewChild, NgModule, TemplateRef, Injectable, Injector, SkipSelf, ɵɵdefineInjectable, ɵɵinject, INJECTOR } from '@angular/core';\r\nimport { AnimationDurations, AnimationCurves, MatCommonModule } from '@angular/material/core';\r\nimport { Breakpoints, BreakpointObserver } from '@angular/cdk/layout';\r\nimport { trigger, state, style, transition, animate } from '@angular/animations';\r\nimport { FocusTrapFactory } from '@angular/cdk/a11y';\r\nimport { Directionality } from '@angular/cdk/bidi';\r\nimport { Subject, merge, of } from 'rxjs';\r\nimport { ESCAPE, hasModifierKey } from '@angular/cdk/keycodes';\r\nimport { filter, take } from 'rxjs/operators';\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: src/material/bottom-sheet/bottom-sheet-config.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Injection token that can be used to access the data that was passed in to a bottom sheet.\r\n * @type {?}\r\n */\r\nconst MAT_BOTTOM_SHEET_DATA = new InjectionToken('MatBottomSheetData');\r\n/**\r\n * Configuration used when opening a bottom sheet.\r\n * @template D\r\n */\r\nclass MatBottomSheetConfig {\r\n    constructor() {\r\n        /**\r\n         * Data being injected into the child component.\r\n         */\r\n        this.data = null;\r\n        /**\r\n         * Whether the bottom sheet has a backdrop.\r\n         */\r\n        this.hasBackdrop = true;\r\n        /**\r\n         * Whether the user can use escape or clicking outside to close the bottom sheet.\r\n         */\r\n        this.disableClose = false;\r\n        /**\r\n         * Aria label to assign to the bottom sheet element.\r\n         */\r\n        this.ariaLabel = null;\r\n        /**\r\n         * Whether the bottom sheet should close when the user goes backwards/forwards in history.\r\n         * Note that this usually doesn't include clicking on links (unless the user is using\r\n         * the `HashLocationStrategy`).\r\n         */\r\n        this.closeOnNavigation = true;\r\n        // Note that this is disabled by default, because while the a11y recommendations are to focus\r\n        // the first focusable element, doing so prevents screen readers from reading out the\r\n        // rest of the bottom sheet content.\r\n        /**\r\n         * Whether the bottom sheet should focus the first focusable element on open.\r\n         */\r\n        this.autoFocus = false;\r\n        /**\r\n         * Whether the bottom sheet should restore focus to the\r\n         * previously-focused element, after it's closed.\r\n         */\r\n        this.restoreFocus = true;\r\n    }\r\n}\r\nif (false) {\r\n    /**\r\n     * The view container to place the overlay for the bottom sheet into.\r\n     * @type {?}\r\n     */\r\n    MatBottomSheetConfig.prototype.viewContainerRef;\r\n    /**\r\n     * Extra CSS classes to be added to the bottom sheet container.\r\n     * @type {?}\r\n     */\r\n    MatBottomSheetConfig.prototype.panelClass;\r\n    /**\r\n     * Text layout direction for the bottom sheet.\r\n     * @type {?}\r\n     */\r\n    MatBottomSheetConfig.prototype.direction;\r\n    /**\r\n     * Data being injected into the child component.\r\n     * @type {?}\r\n     */\r\n    MatBottomSheetConfig.prototype.data;\r\n    /**\r\n     * Whether the bottom sheet has a backdrop.\r\n     * @type {?}\r\n     */\r\n    MatBottomSheetConfig.prototype.hasBackdrop;\r\n    /**\r\n     * Custom class for the backdrop.\r\n     * @type {?}\r\n     */\r\n    MatBottomSheetConfig.prototype.backdropClass;\r\n    /**\r\n     * Whether the user can use escape or clicking outside to close the bottom sheet.\r\n     * @type {?}\r\n     */\r\n    MatBottomSheetConfig.prototype.disableClose;\r\n    /**\r\n     * Aria label to assign to the bottom sheet element.\r\n     * @type {?}\r\n     */\r\n    MatBottomSheetConfig.prototype.ariaLabel;\r\n    /**\r\n     * Whether the bottom sheet should close when the user goes backwards/forwards in history.\r\n     * Note that this usually doesn't include clicking on links (unless the user is using\r\n     * the `HashLocationStrategy`).\r\n     * @type {?}\r\n     */\r\n    MatBottomSheetConfig.prototype.closeOnNavigation;\r\n    /**\r\n     * Whether the bottom sheet should focus the first focusable element on open.\r\n     * @type {?}\r\n     */\r\n    MatBottomSheetConfig.prototype.autoFocus;\r\n    /**\r\n     * Whether the bottom sheet should restore focus to the\r\n     * previously-focused element, after it's closed.\r\n     * @type {?}\r\n     */\r\n    MatBottomSheetConfig.prototype.restoreFocus;\r\n    /**\r\n     * Scroll strategy to be used for the bottom sheet.\r\n     * @type {?}\r\n     */\r\n    MatBottomSheetConfig.prototype.scrollStrategy;\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: src/material/bottom-sheet/bottom-sheet-animations.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Animations used by the Material bottom sheet.\r\n * @type {?}\r\n */\r\nconst matBottomSheetAnimations = {\r\n    /**\r\n     * Animation that shows and hides a bottom sheet.\r\n     */\r\n    bottomSheetState: trigger('state', [\r\n        state('void, hidden', style({ transform: 'translateY(100%)' })),\r\n        state('visible', style({ transform: 'translateY(0%)' })),\r\n        transition('visible => void, visible => hidden', animate(`${AnimationDurations.COMPLEX} ${AnimationCurves.ACCELERATION_CURVE}`)),\r\n        transition('void => visible', animate(`${AnimationDurations.EXITING} ${AnimationCurves.DECELERATION_CURVE}`)),\r\n    ])\r\n};\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: src/material/bottom-sheet/bottom-sheet-container.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n// TODO(crisbeto): consolidate some logic between this, MatDialog and MatSnackBar\r\n/**\r\n * Internal component that wraps user-provided bottom sheet content.\r\n * \\@docs-private\r\n */\r\nclass MatBottomSheetContainer extends BasePortalOutlet {\r\n    /**\r\n     * @param {?} _elementRef\r\n     * @param {?} _changeDetectorRef\r\n     * @param {?} _focusTrapFactory\r\n     * @param {?} breakpointObserver\r\n     * @param {?} document\r\n     * @param {?} bottomSheetConfig\r\n     */\r\n    constructor(_elementRef, _changeDetectorRef, _focusTrapFactory, breakpointObserver, document, bottomSheetConfig) {\r\n        super();\r\n        this._elementRef = _elementRef;\r\n        this._changeDetectorRef = _changeDetectorRef;\r\n        this._focusTrapFactory = _focusTrapFactory;\r\n        this.bottomSheetConfig = bottomSheetConfig;\r\n        /**\r\n         * The state of the bottom sheet animations.\r\n         */\r\n        this._animationState = 'void';\r\n        /**\r\n         * Emits whenever the state of the animation changes.\r\n         */\r\n        this._animationStateChanged = new EventEmitter();\r\n        /**\r\n         * Element that was focused before the bottom sheet was opened.\r\n         */\r\n        this._elementFocusedBeforeOpened = null;\r\n        /**\r\n         * Attaches a DOM portal to the bottom sheet container.\r\n         * @deprecated To be turned into a method.\r\n         * \\@breaking-change 10.0.0\r\n         */\r\n        this.attachDomPortal = (/**\r\n         * @param {?} portal\r\n         * @return {?}\r\n         */\r\n        (portal) => {\r\n            this._validatePortalAttached();\r\n            this._setPanelClass();\r\n            this._savePreviouslyFocusedElement();\r\n            return this._portalOutlet.attachDomPortal(portal);\r\n        });\r\n        this._document = document;\r\n        this._breakpointSubscription = breakpointObserver\r\n            .observe([Breakpoints.Medium, Breakpoints.Large, Breakpoints.XLarge])\r\n            .subscribe((/**\r\n         * @return {?}\r\n         */\r\n        () => {\r\n            this._toggleClass('mat-bottom-sheet-container-medium', breakpointObserver.isMatched(Breakpoints.Medium));\r\n            this._toggleClass('mat-bottom-sheet-container-large', breakpointObserver.isMatched(Breakpoints.Large));\r\n            this._toggleClass('mat-bottom-sheet-container-xlarge', breakpointObserver.isMatched(Breakpoints.XLarge));\r\n        }));\r\n    }\r\n    /**\r\n     * Attach a component portal as content to this bottom sheet container.\r\n     * @template T\r\n     * @param {?} portal\r\n     * @return {?}\r\n     */\r\n    attachComponentPortal(portal) {\r\n        this._validatePortalAttached();\r\n        this._setPanelClass();\r\n        this._savePreviouslyFocusedElement();\r\n        return this._portalOutlet.attachComponentPortal(portal);\r\n    }\r\n    /**\r\n     * Attach a template portal as content to this bottom sheet container.\r\n     * @template C\r\n     * @param {?} portal\r\n     * @return {?}\r\n     */\r\n    attachTemplatePortal(portal) {\r\n        this._validatePortalAttached();\r\n        this._setPanelClass();\r\n        this._savePreviouslyFocusedElement();\r\n        return this._portalOutlet.attachTemplatePortal(portal);\r\n    }\r\n    /**\r\n     * Begin animation of bottom sheet entrance into view.\r\n     * @return {?}\r\n     */\r\n    enter() {\r\n        if (!this._destroyed) {\r\n            this._animationState = 'visible';\r\n            this._changeDetectorRef.detectChanges();\r\n        }\r\n    }\r\n    /**\r\n     * Begin animation of the bottom sheet exiting from view.\r\n     * @return {?}\r\n     */\r\n    exit() {\r\n        if (!this._destroyed) {\r\n            this._animationState = 'hidden';\r\n            this._changeDetectorRef.markForCheck();\r\n        }\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnDestroy() {\r\n        this._breakpointSubscription.unsubscribe();\r\n        this._destroyed = true;\r\n    }\r\n    /**\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    _onAnimationDone(event) {\r\n        if (event.toState === 'hidden') {\r\n            this._restoreFocus();\r\n        }\r\n        else if (event.toState === 'visible') {\r\n            this._trapFocus();\r\n        }\r\n        this._animationStateChanged.emit(event);\r\n    }\r\n    /**\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    _onAnimationStart(event) {\r\n        this._animationStateChanged.emit(event);\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?} cssClass\r\n     * @param {?} add\r\n     * @return {?}\r\n     */\r\n    _toggleClass(cssClass, add) {\r\n        /** @type {?} */\r\n        const classList = this._elementRef.nativeElement.classList;\r\n        add ? classList.add(cssClass) : classList.remove(cssClass);\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _validatePortalAttached() {\r\n        if (this._portalOutlet.hasAttached()) {\r\n            throw Error('Attempting to attach bottom sheet content after content is already attached');\r\n        }\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _setPanelClass() {\r\n        /** @type {?} */\r\n        const element = this._elementRef.nativeElement;\r\n        /** @type {?} */\r\n        const panelClass = this.bottomSheetConfig.panelClass;\r\n        if (Array.isArray(panelClass)) {\r\n            // Note that we can't use a spread here, because IE doesn't support multiple arguments.\r\n            panelClass.forEach((/**\r\n             * @param {?} cssClass\r\n             * @return {?}\r\n             */\r\n            cssClass => element.classList.add(cssClass)));\r\n        }\r\n        else if (panelClass) {\r\n            element.classList.add(panelClass);\r\n        }\r\n    }\r\n    /**\r\n     * Moves the focus inside the focus trap.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _trapFocus() {\r\n        /** @type {?} */\r\n        const element = this._elementRef.nativeElement;\r\n        if (!this._focusTrap) {\r\n            this._focusTrap = this._focusTrapFactory.create(element);\r\n        }\r\n        if (this.bottomSheetConfig.autoFocus) {\r\n            this._focusTrap.focusInitialElementWhenReady();\r\n        }\r\n        else {\r\n            /** @type {?} */\r\n            const activeElement = this._document.activeElement;\r\n            // Otherwise ensure that focus is on the container. It's possible that a different\r\n            // component tried to move focus while the open animation was running. See:\r\n            // https://github.com/angular/components/issues/16215. Note that we only want to do this\r\n            // if the focus isn't inside the bottom sheet already, because it's possible that the\r\n            // consumer turned off `autoFocus` in order to move focus themselves.\r\n            if (activeElement !== element && !element.contains(activeElement)) {\r\n                element.focus();\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Restores focus to the element that was focused before the bottom sheet was opened.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _restoreFocus() {\r\n        /** @type {?} */\r\n        const toFocus = this._elementFocusedBeforeOpened;\r\n        // We need the extra check, because IE can set the `activeElement` to null in some cases.\r\n        if (this.bottomSheetConfig.restoreFocus && toFocus && typeof toFocus.focus === 'function') {\r\n            /** @type {?} */\r\n            const activeElement = this._document.activeElement;\r\n            /** @type {?} */\r\n            const element = this._elementRef.nativeElement;\r\n            // Make sure that focus is still inside the bottom sheet or is on the body (usually because a\r\n            // non-focusable element like the backdrop was clicked) before moving it. It's possible that\r\n            // the consumer moved it themselves before the animation was done, in which case we shouldn't\r\n            // do anything.\r\n            if (!activeElement || activeElement === this._document.body || activeElement === element ||\r\n                element.contains(activeElement)) {\r\n                toFocus.focus();\r\n            }\r\n        }\r\n        if (this._focusTrap) {\r\n            this._focusTrap.destroy();\r\n        }\r\n    }\r\n    /**\r\n     * Saves a reference to the element that was focused before the bottom sheet was opened.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _savePreviouslyFocusedElement() {\r\n        this._elementFocusedBeforeOpened = (/** @type {?} */ (this._document.activeElement));\r\n        // The `focus` method isn't available during server-side rendering.\r\n        if (this._elementRef.nativeElement.focus) {\r\n            Promise.resolve().then((/**\r\n             * @return {?}\r\n             */\r\n            () => this._elementRef.nativeElement.focus()));\r\n        }\r\n    }\r\n}\r\nMatBottomSheetContainer.decorators = [\r\n    { type: Component, args: [{\r\n                selector: 'mat-bottom-sheet-container',\r\n                template: \"<ng-template cdkPortalOutlet></ng-template>\\r\\n\",\r\n                changeDetection: ChangeDetectionStrategy.OnPush,\r\n                encapsulation: ViewEncapsulation.None,\r\n                animations: [matBottomSheetAnimations.bottomSheetState],\r\n                host: {\r\n                    'class': 'mat-bottom-sheet-container',\r\n                    'tabindex': '-1',\r\n                    'role': 'dialog',\r\n                    'aria-modal': 'true',\r\n                    '[attr.aria-label]': 'bottomSheetConfig?.ariaLabel',\r\n                    '[@state]': '_animationState',\r\n                    '(@state.start)': '_onAnimationStart($event)',\r\n                    '(@state.done)': '_onAnimationDone($event)'\r\n                },\r\n                styles: [\".mat-bottom-sheet-container{padding:8px 16px;min-width:100vw;box-sizing:border-box;display:block;outline:0;max-height:80vh;overflow:auto}.cdk-high-contrast-active .mat-bottom-sheet-container{outline:1px solid}.mat-bottom-sheet-container-xlarge,.mat-bottom-sheet-container-large,.mat-bottom-sheet-container-medium{border-top-left-radius:4px;border-top-right-radius:4px}.mat-bottom-sheet-container-medium{min-width:384px;max-width:calc(100vw - 128px)}.mat-bottom-sheet-container-large{min-width:512px;max-width:calc(100vw - 256px)}.mat-bottom-sheet-container-xlarge{min-width:576px;max-width:calc(100vw - 384px)}\\n\"]\r\n            }] }\r\n];\r\n/** @nocollapse */\r\nMatBottomSheetContainer.ctorParameters = () => [\r\n    { type: ElementRef },\r\n    { type: ChangeDetectorRef },\r\n    { type: FocusTrapFactory },\r\n    { type: BreakpointObserver },\r\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] },\r\n    { type: MatBottomSheetConfig }\r\n];\r\nMatBottomSheetContainer.propDecorators = {\r\n    _portalOutlet: [{ type: ViewChild, args: [CdkPortalOutlet, { static: true },] }]\r\n};\r\nif (false) {\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    MatBottomSheetContainer.prototype._breakpointSubscription;\r\n    /**\r\n     * The portal outlet inside of this container into which the content will be loaded.\r\n     * @type {?}\r\n     */\r\n    MatBottomSheetContainer.prototype._portalOutlet;\r\n    /**\r\n     * The state of the bottom sheet animations.\r\n     * @type {?}\r\n     */\r\n    MatBottomSheetContainer.prototype._animationState;\r\n    /**\r\n     * Emits whenever the state of the animation changes.\r\n     * @type {?}\r\n     */\r\n    MatBottomSheetContainer.prototype._animationStateChanged;\r\n    /**\r\n     * The class that traps and manages focus within the bottom sheet.\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    MatBottomSheetContainer.prototype._focusTrap;\r\n    /**\r\n     * Element that was focused before the bottom sheet was opened.\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    MatBottomSheetContainer.prototype._elementFocusedBeforeOpened;\r\n    /**\r\n     * Server-side rendering-compatible reference to the global document object.\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    MatBottomSheetContainer.prototype._document;\r\n    /**\r\n     * Whether the component has been destroyed.\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    MatBottomSheetContainer.prototype._destroyed;\r\n    /**\r\n     * Attaches a DOM portal to the bottom sheet container.\r\n     * @deprecated To be turned into a method.\r\n     * \\@breaking-change 10.0.0\r\n     * @type {?}\r\n     */\r\n    MatBottomSheetContainer.prototype.attachDomPortal;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    MatBottomSheetContainer.prototype._elementRef;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    MatBottomSheetContainer.prototype._changeDetectorRef;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    MatBottomSheetContainer.prototype._focusTrapFactory;\r\n    /**\r\n     * The bottom sheet configuration.\r\n     * @type {?}\r\n     */\r\n    MatBottomSheetContainer.prototype.bottomSheetConfig;\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: src/material/bottom-sheet/bottom-sheet-module.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nclass MatBottomSheetModule {\r\n}\r\nMatBottomSheetModule.decorators = [\r\n    { type: NgModule, args: [{\r\n                imports: [\r\n                    CommonModule,\r\n                    OverlayModule,\r\n                    MatCommonModule,\r\n                    PortalModule,\r\n                ],\r\n                exports: [MatBottomSheetContainer, MatCommonModule],\r\n                declarations: [MatBottomSheetContainer],\r\n                entryComponents: [MatBottomSheetContainer],\r\n            },] }\r\n];\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: src/material/bottom-sheet/bottom-sheet-ref.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Reference to a bottom sheet dispatched from the bottom sheet service.\r\n * @template T, R\r\n */\r\nclass MatBottomSheetRef {\r\n    /**\r\n     * @param {?} containerInstance\r\n     * @param {?} _overlayRef\r\n     * @param {?=} _location\r\n     */\r\n    constructor(containerInstance, _overlayRef, \r\n    // @breaking-change 8.0.0 `_location` parameter to be removed.\r\n    _location) {\r\n        this._overlayRef = _overlayRef;\r\n        /**\r\n         * Subject for notifying the user that the bottom sheet has been dismissed.\r\n         */\r\n        this._afterDismissed = new Subject();\r\n        /**\r\n         * Subject for notifying the user that the bottom sheet has opened and appeared.\r\n         */\r\n        this._afterOpened = new Subject();\r\n        this.containerInstance = containerInstance;\r\n        this.disableClose = containerInstance.bottomSheetConfig.disableClose;\r\n        // Emit when opening animation completes\r\n        containerInstance._animationStateChanged.pipe(filter((/**\r\n         * @param {?} event\r\n         * @return {?}\r\n         */\r\n        event => event.phaseName === 'done' && event.toState === 'visible')), take(1))\r\n            .subscribe((/**\r\n         * @return {?}\r\n         */\r\n        () => {\r\n            this._afterOpened.next();\r\n            this._afterOpened.complete();\r\n        }));\r\n        // Dispose overlay when closing animation is complete\r\n        containerInstance._animationStateChanged\r\n            .pipe(filter((/**\r\n         * @param {?} event\r\n         * @return {?}\r\n         */\r\n        event => event.phaseName === 'done' && event.toState === 'hidden')), take(1))\r\n            .subscribe((/**\r\n         * @return {?}\r\n         */\r\n        () => {\r\n            clearTimeout(this._closeFallbackTimeout);\r\n            _overlayRef.dispose();\r\n        }));\r\n        _overlayRef.detachments().pipe(take(1)).subscribe((/**\r\n         * @return {?}\r\n         */\r\n        () => {\r\n            this._afterDismissed.next(this._result);\r\n            this._afterDismissed.complete();\r\n        }));\r\n        merge(_overlayRef.backdropClick(), _overlayRef.keydownEvents().pipe(filter((/**\r\n         * @param {?} event\r\n         * @return {?}\r\n         */\r\n        event => event.keyCode === ESCAPE)))).subscribe((/**\r\n         * @param {?} event\r\n         * @return {?}\r\n         */\r\n        event => {\r\n            if (!this.disableClose &&\r\n                (event.type !== 'keydown' || !hasModifierKey((/** @type {?} */ (event))))) {\r\n                event.preventDefault();\r\n                this.dismiss();\r\n            }\r\n        }));\r\n    }\r\n    /**\r\n     * Dismisses the bottom sheet.\r\n     * @param {?=} result Data to be passed back to the bottom sheet opener.\r\n     * @return {?}\r\n     */\r\n    dismiss(result) {\r\n        if (!this._afterDismissed.closed) {\r\n            // Transition the backdrop in parallel to the bottom sheet.\r\n            this.containerInstance._animationStateChanged.pipe(filter((/**\r\n             * @param {?} event\r\n             * @return {?}\r\n             */\r\n            event => event.phaseName === 'start')), take(1)).subscribe((/**\r\n             * @param {?} event\r\n             * @return {?}\r\n             */\r\n            event => {\r\n                // The logic that disposes of the overlay depends on the exit animation completing, however\r\n                // it isn't guaranteed if the parent view is destroyed while it's running. Add a fallback\r\n                // timeout which will clean everything up if the animation hasn't fired within the specified\r\n                // amount of time plus 100ms. We don't need to run this outside the NgZone, because for the\r\n                // vast majority of cases the timeout will have been cleared before it has fired.\r\n                this._closeFallbackTimeout = setTimeout((/**\r\n                 * @return {?}\r\n                 */\r\n                () => {\r\n                    this._overlayRef.dispose();\r\n                }), event.totalTime + 100);\r\n                this._overlayRef.detachBackdrop();\r\n            }));\r\n            this._result = result;\r\n            this.containerInstance.exit();\r\n        }\r\n    }\r\n    /**\r\n     * Gets an observable that is notified when the bottom sheet is finished closing.\r\n     * @return {?}\r\n     */\r\n    afterDismissed() {\r\n        return this._afterDismissed.asObservable();\r\n    }\r\n    /**\r\n     * Gets an observable that is notified when the bottom sheet has opened and appeared.\r\n     * @return {?}\r\n     */\r\n    afterOpened() {\r\n        return this._afterOpened.asObservable();\r\n    }\r\n    /**\r\n     * Gets an observable that emits when the overlay's backdrop has been clicked.\r\n     * @return {?}\r\n     */\r\n    backdropClick() {\r\n        return this._overlayRef.backdropClick();\r\n    }\r\n    /**\r\n     * Gets an observable that emits when keydown events are targeted on the overlay.\r\n     * @return {?}\r\n     */\r\n    keydownEvents() {\r\n        return this._overlayRef.keydownEvents();\r\n    }\r\n}\r\nif (false) {\r\n    /**\r\n     * Instance of the component making up the content of the bottom sheet.\r\n     * @type {?}\r\n     */\r\n    MatBottomSheetRef.prototype.instance;\r\n    /**\r\n     * Instance of the component into which the bottom sheet content is projected.\r\n     * \\@docs-private\r\n     * @type {?}\r\n     */\r\n    MatBottomSheetRef.prototype.containerInstance;\r\n    /**\r\n     * Whether the user is allowed to close the bottom sheet.\r\n     * @type {?}\r\n     */\r\n    MatBottomSheetRef.prototype.disableClose;\r\n    /**\r\n     * Subject for notifying the user that the bottom sheet has been dismissed.\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    MatBottomSheetRef.prototype._afterDismissed;\r\n    /**\r\n     * Subject for notifying the user that the bottom sheet has opened and appeared.\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    MatBottomSheetRef.prototype._afterOpened;\r\n    /**\r\n     * Result to be passed down to the `afterDismissed` stream.\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    MatBottomSheetRef.prototype._result;\r\n    /**\r\n     * Handle to the timeout that's running as a fallback in case the exit animation doesn't fire.\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    MatBottomSheetRef.prototype._closeFallbackTimeout;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    MatBottomSheetRef.prototype._overlayRef;\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: src/material/bottom-sheet/bottom-sheet.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Injection token that can be used to specify default bottom sheet options.\r\n * @type {?}\r\n */\r\nconst MAT_BOTTOM_SHEET_DEFAULT_OPTIONS = new InjectionToken('mat-bottom-sheet-default-options');\r\n/**\r\n * Service to trigger Material Design bottom sheets.\r\n */\r\nclass MatBottomSheet {\r\n    /**\r\n     * @param {?} _overlay\r\n     * @param {?} _injector\r\n     * @param {?} _parentBottomSheet\r\n     * @param {?=} _location\r\n     * @param {?=} _defaultOptions\r\n     */\r\n    constructor(_overlay, _injector, _parentBottomSheet, _location, _defaultOptions) {\r\n        this._overlay = _overlay;\r\n        this._injector = _injector;\r\n        this._parentBottomSheet = _parentBottomSheet;\r\n        this._location = _location;\r\n        this._defaultOptions = _defaultOptions;\r\n        this._bottomSheetRefAtThisLevel = null;\r\n    }\r\n    /**\r\n     * Reference to the currently opened bottom sheet.\r\n     * @return {?}\r\n     */\r\n    get _openedBottomSheetRef() {\r\n        /** @type {?} */\r\n        const parent = this._parentBottomSheet;\r\n        return parent ? parent._openedBottomSheetRef : this._bottomSheetRefAtThisLevel;\r\n    }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set _openedBottomSheetRef(value) {\r\n        if (this._parentBottomSheet) {\r\n            this._parentBottomSheet._openedBottomSheetRef = value;\r\n        }\r\n        else {\r\n            this._bottomSheetRefAtThisLevel = value;\r\n        }\r\n    }\r\n    /**\r\n     * @template T, D, R\r\n     * @param {?} componentOrTemplateRef\r\n     * @param {?=} config\r\n     * @return {?}\r\n     */\r\n    open(componentOrTemplateRef, config) {\r\n        /** @type {?} */\r\n        const _config = _applyConfigDefaults(this._defaultOptions || new MatBottomSheetConfig(), config);\r\n        /** @type {?} */\r\n        const overlayRef = this._createOverlay(_config);\r\n        /** @type {?} */\r\n        const container = this._attachContainer(overlayRef, _config);\r\n        /** @type {?} */\r\n        const ref = new MatBottomSheetRef(container, overlayRef, this._location);\r\n        if (componentOrTemplateRef instanceof TemplateRef) {\r\n            container.attachTemplatePortal(new TemplatePortal(componentOrTemplateRef, (/** @type {?} */ (null)), (/** @type {?} */ ({\r\n                $implicit: _config.data,\r\n                bottomSheetRef: ref\r\n            }))));\r\n        }\r\n        else {\r\n            /** @type {?} */\r\n            const portal = new ComponentPortal(componentOrTemplateRef, undefined, this._createInjector(_config, ref));\r\n            /** @type {?} */\r\n            const contentRef = container.attachComponentPortal(portal);\r\n            ref.instance = contentRef.instance;\r\n        }\r\n        // When the bottom sheet is dismissed, clear the reference to it.\r\n        ref.afterDismissed().subscribe((/**\r\n         * @return {?}\r\n         */\r\n        () => {\r\n            // Clear the bottom sheet ref if it hasn't already been replaced by a newer one.\r\n            if (this._openedBottomSheetRef == ref) {\r\n                this._openedBottomSheetRef = null;\r\n            }\r\n        }));\r\n        if (this._openedBottomSheetRef) {\r\n            // If a bottom sheet is already in view, dismiss it and enter the\r\n            // new bottom sheet after exit animation is complete.\r\n            this._openedBottomSheetRef.afterDismissed().subscribe((/**\r\n             * @return {?}\r\n             */\r\n            () => ref.containerInstance.enter()));\r\n            this._openedBottomSheetRef.dismiss();\r\n        }\r\n        else {\r\n            // If no bottom sheet is in view, enter the new bottom sheet.\r\n            ref.containerInstance.enter();\r\n        }\r\n        this._openedBottomSheetRef = ref;\r\n        return ref;\r\n    }\r\n    /**\r\n     * Dismisses the currently-visible bottom sheet.\r\n     * @return {?}\r\n     */\r\n    dismiss() {\r\n        if (this._openedBottomSheetRef) {\r\n            this._openedBottomSheetRef.dismiss();\r\n        }\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnDestroy() {\r\n        if (this._bottomSheetRefAtThisLevel) {\r\n            this._bottomSheetRefAtThisLevel.dismiss();\r\n        }\r\n    }\r\n    /**\r\n     * Attaches the bottom sheet container component to the overlay.\r\n     * @private\r\n     * @param {?} overlayRef\r\n     * @param {?} config\r\n     * @return {?}\r\n     */\r\n    _attachContainer(overlayRef, config) {\r\n        /** @type {?} */\r\n        const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;\r\n        /** @type {?} */\r\n        const injector = new PortalInjector(userInjector || this._injector, new WeakMap([\r\n            [MatBottomSheetConfig, config]\r\n        ]));\r\n        /** @type {?} */\r\n        const containerPortal = new ComponentPortal(MatBottomSheetContainer, config.viewContainerRef, injector);\r\n        /** @type {?} */\r\n        const containerRef = overlayRef.attach(containerPortal);\r\n        return containerRef.instance;\r\n    }\r\n    /**\r\n     * Creates a new overlay and places it in the correct location.\r\n     * @private\r\n     * @param {?} config The user-specified bottom sheet config.\r\n     * @return {?}\r\n     */\r\n    _createOverlay(config) {\r\n        /** @type {?} */\r\n        const overlayConfig = new OverlayConfig({\r\n            direction: config.direction,\r\n            hasBackdrop: config.hasBackdrop,\r\n            disposeOnNavigation: config.closeOnNavigation,\r\n            maxWidth: '100%',\r\n            scrollStrategy: config.scrollStrategy || this._overlay.scrollStrategies.block(),\r\n            positionStrategy: this._overlay.position().global().centerHorizontally().bottom('0')\r\n        });\r\n        if (config.backdropClass) {\r\n            overlayConfig.backdropClass = config.backdropClass;\r\n        }\r\n        return this._overlay.create(overlayConfig);\r\n    }\r\n    /**\r\n     * Creates an injector to be used inside of a bottom sheet component.\r\n     * @private\r\n     * @template T\r\n     * @param {?} config Config that was used to create the bottom sheet.\r\n     * @param {?} bottomSheetRef Reference to the bottom sheet.\r\n     * @return {?}\r\n     */\r\n    _createInjector(config, bottomSheetRef) {\r\n        /** @type {?} */\r\n        const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;\r\n        /** @type {?} */\r\n        const injectionTokens = new WeakMap([\r\n            [MatBottomSheetRef, bottomSheetRef],\r\n            [MAT_BOTTOM_SHEET_DATA, config.data]\r\n        ]);\r\n        if (config.direction &&\r\n            (!userInjector || !userInjector.get(Directionality, null))) {\r\n            injectionTokens.set(Directionality, {\r\n                value: config.direction,\r\n                change: of()\r\n            });\r\n        }\r\n        return new PortalInjector(userInjector || this._injector, injectionTokens);\r\n    }\r\n}\r\nMatBottomSheet.decorators = [\r\n    { type: Injectable, args: [{ providedIn: MatBottomSheetModule },] }\r\n];\r\n/** @nocollapse */\r\nMatBottomSheet.ctorParameters = () => [\r\n    { type: Overlay },\r\n    { type: Injector },\r\n    { type: MatBottomSheet, decorators: [{ type: Optional }, { type: SkipSelf }] },\r\n    { type: Location, decorators: [{ type: Optional }] },\r\n    { type: MatBottomSheetConfig, decorators: [{ type: Optional }, { type: Inject, args: [MAT_BOTTOM_SHEET_DEFAULT_OPTIONS,] }] }\r\n];\r\n/** @nocollapse */ MatBottomSheet.ɵprov = ɵɵdefineInjectable({ factory: function MatBottomSheet_Factory() { return new MatBottomSheet(ɵɵinject(Overlay), ɵɵinject(INJECTOR), ɵɵinject(MatBottomSheet, 12), ɵɵinject(Location, 8), ɵɵinject(MAT_BOTTOM_SHEET_DEFAULT_OPTIONS, 8)); }, token: MatBottomSheet, providedIn: MatBottomSheetModule });\r\nif (false) {\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    MatBottomSheet.prototype._bottomSheetRefAtThisLevel;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    MatBottomSheet.prototype._overlay;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    MatBottomSheet.prototype._injector;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    MatBottomSheet.prototype._parentBottomSheet;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    MatBottomSheet.prototype._location;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    MatBottomSheet.prototype._defaultOptions;\r\n}\r\n/**\r\n * Applies default options to the bottom sheet config.\r\n * @param {?} defaults Object containing the default values to which to fall back.\r\n * @param {?=} config The configuration to which the defaults will be applied.\r\n * @return {?} The new configuration object with defaults applied.\r\n */\r\nfunction _applyConfigDefaults(defaults, config) {\r\n    return Object.assign(Object.assign({}, defaults), config);\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: src/material/bottom-sheet/public-api.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * Generated bundle index. Do not edit.\r\n */\r\n\r\nexport { MAT_BOTTOM_SHEET_DATA, MAT_BOTTOM_SHEET_DEFAULT_OPTIONS, MatBottomSheet, MatBottomSheetConfig, MatBottomSheetContainer, MatBottomSheetModule, MatBottomSheetRef, matBottomSheetAnimations };\r\n\r\n"]}