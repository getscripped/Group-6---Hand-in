{"version":3,"sources":["D:/370/FinalFrontend/node_modules/@angular/material/fesm2015/badge.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAoRC,qaAmBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAiBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4FD;;;;;;;;;;;;;0BAUC","file":"badge.js","sourcesContent":["import { isDevMode, Directive, NgZone, ElementRef, Renderer2, Optional, Inject, Input, NgModule } from '@angular/core';\r\nimport { mixinDisabled, MatCommonModule } from '@angular/material/core';\r\nimport { AriaDescriber, A11yModule } from '@angular/cdk/a11y';\r\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\r\nimport { ANIMATION_MODULE_TYPE } from '@angular/platform-browser/animations';\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: src/material/badge/badge.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/** @type {?} */\r\nlet nextId = 0;\r\n// Boilerplate for applying mixins to MatBadge.\r\n/**\r\n * \\@docs-private\r\n */\r\nclass MatBadgeBase {\r\n}\r\n/** @type {?} */\r\nconst _MatBadgeMixinBase = mixinDisabled(MatBadgeBase);\r\n/**\r\n * Directive to display a text badge.\r\n */\r\nclass MatBadge extends _MatBadgeMixinBase {\r\n    /**\r\n     * @param {?} _ngZone\r\n     * @param {?} _elementRef\r\n     * @param {?} _ariaDescriber\r\n     * @param {?} _renderer\r\n     * @param {?=} _animationMode\r\n     */\r\n    constructor(_ngZone, _elementRef, _ariaDescriber, _renderer, _animationMode) {\r\n        super();\r\n        this._ngZone = _ngZone;\r\n        this._elementRef = _elementRef;\r\n        this._ariaDescriber = _ariaDescriber;\r\n        this._renderer = _renderer;\r\n        this._animationMode = _animationMode;\r\n        /**\r\n         * Whether the badge has any content.\r\n         */\r\n        this._hasContent = false;\r\n        this._color = 'primary';\r\n        this._overlap = true;\r\n        /**\r\n         * Position the badge should reside.\r\n         * Accepts any combination of 'above'|'below' and 'before'|'after'\r\n         */\r\n        this.position = 'above after';\r\n        /**\r\n         * Size of the badge. Can be 'small', 'medium', or 'large'.\r\n         */\r\n        this.size = 'medium';\r\n        /**\r\n         * Unique id for the badge\r\n         */\r\n        this._id = nextId++;\r\n        if (isDevMode()) {\r\n            /** @type {?} */\r\n            const nativeElement = _elementRef.nativeElement;\r\n            if (nativeElement.nodeType !== nativeElement.ELEMENT_NODE) {\r\n                throw Error('matBadge must be attached to an element node.');\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * The color of the badge. Can be `primary`, `accent`, or `warn`.\r\n     * @return {?}\r\n     */\r\n    get color() { return this._color; }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set color(value) {\r\n        this._setColor(value);\r\n        this._color = value;\r\n    }\r\n    /**\r\n     * Whether the badge should overlap its contents or not\r\n     * @return {?}\r\n     */\r\n    get overlap() { return this._overlap; }\r\n    /**\r\n     * @param {?} val\r\n     * @return {?}\r\n     */\r\n    set overlap(val) {\r\n        this._overlap = coerceBooleanProperty(val);\r\n    }\r\n    /**\r\n     * Message used to describe the decorated element via aria-describedby\r\n     * @return {?}\r\n     */\r\n    get description() { return this._description; }\r\n    /**\r\n     * @param {?} newDescription\r\n     * @return {?}\r\n     */\r\n    set description(newDescription) {\r\n        if (newDescription !== this._description) {\r\n            /** @type {?} */\r\n            const badgeElement = this._badgeElement;\r\n            this._updateHostAriaDescription(newDescription, this._description);\r\n            this._description = newDescription;\r\n            if (badgeElement) {\r\n                newDescription ? badgeElement.setAttribute('aria-label', newDescription) :\r\n                    badgeElement.removeAttribute('aria-label');\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Whether the badge is hidden.\r\n     * @return {?}\r\n     */\r\n    get hidden() { return this._hidden; }\r\n    /**\r\n     * @param {?} val\r\n     * @return {?}\r\n     */\r\n    set hidden(val) {\r\n        this._hidden = coerceBooleanProperty(val);\r\n    }\r\n    /**\r\n     * Whether the badge is above the host or not\r\n     * @return {?}\r\n     */\r\n    isAbove() {\r\n        return this.position.indexOf('below') === -1;\r\n    }\r\n    /**\r\n     * Whether the badge is after the host or not\r\n     * @return {?}\r\n     */\r\n    isAfter() {\r\n        return this.position.indexOf('before') === -1;\r\n    }\r\n    /**\r\n     * @param {?} changes\r\n     * @return {?}\r\n     */\r\n    ngOnChanges(changes) {\r\n        /** @type {?} */\r\n        const contentChange = changes['content'];\r\n        if (contentChange) {\r\n            /** @type {?} */\r\n            const value = contentChange.currentValue;\r\n            this._hasContent = value != null && `${value}`.trim().length > 0;\r\n            this._updateTextContent();\r\n        }\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnDestroy() {\r\n        /** @type {?} */\r\n        const badgeElement = this._badgeElement;\r\n        if (badgeElement) {\r\n            if (this.description) {\r\n                this._ariaDescriber.removeDescription(badgeElement, this.description);\r\n            }\r\n            // When creating a badge through the Renderer, Angular will keep it in an index.\r\n            // We have to destroy it ourselves, otherwise it'll be retained in memory.\r\n            if (this._renderer.destroyNode) {\r\n                this._renderer.destroyNode(badgeElement);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Gets the element into which the badge's content is being rendered.\r\n     * Undefined if the element hasn't been created (e.g. if the badge doesn't have content).\r\n     * @return {?}\r\n     */\r\n    getBadgeElement() {\r\n        return this._badgeElement;\r\n    }\r\n    /**\r\n     * Injects a span element into the DOM with the content.\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _updateTextContent() {\r\n        if (!this._badgeElement) {\r\n            this._badgeElement = this._createBadgeElement();\r\n        }\r\n        else {\r\n            this._badgeElement.textContent = this.content;\r\n        }\r\n        return this._badgeElement;\r\n    }\r\n    /**\r\n     * Creates the badge element\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _createBadgeElement() {\r\n        /** @type {?} */\r\n        const badgeElement = this._renderer.createElement('span');\r\n        /** @type {?} */\r\n        const activeClass = 'mat-badge-active';\r\n        /** @type {?} */\r\n        const contentClass = 'mat-badge-content';\r\n        // Clear any existing badges which may have persisted from a server-side render.\r\n        this._clearExistingBadges(contentClass);\r\n        badgeElement.setAttribute('id', `mat-badge-content-${this._id}`);\r\n        badgeElement.classList.add(contentClass);\r\n        badgeElement.textContent = this.content;\r\n        if (this._animationMode === 'NoopAnimations') {\r\n            badgeElement.classList.add('_mat-animation-noopable');\r\n        }\r\n        if (this.description) {\r\n            badgeElement.setAttribute('aria-label', this.description);\r\n        }\r\n        this._elementRef.nativeElement.appendChild(badgeElement);\r\n        // animate in after insertion\r\n        if (typeof requestAnimationFrame === 'function' && this._animationMode !== 'NoopAnimations') {\r\n            this._ngZone.runOutsideAngular((/**\r\n             * @return {?}\r\n             */\r\n            () => {\r\n                requestAnimationFrame((/**\r\n                 * @return {?}\r\n                 */\r\n                () => {\r\n                    badgeElement.classList.add(activeClass);\r\n                }));\r\n            }));\r\n        }\r\n        else {\r\n            badgeElement.classList.add(activeClass);\r\n        }\r\n        return badgeElement;\r\n    }\r\n    /**\r\n     * Sets the aria-label property on the element\r\n     * @private\r\n     * @param {?} newDescription\r\n     * @param {?} oldDescription\r\n     * @return {?}\r\n     */\r\n    _updateHostAriaDescription(newDescription, oldDescription) {\r\n        // ensure content available before setting label\r\n        /** @type {?} */\r\n        const content = this._updateTextContent();\r\n        if (oldDescription) {\r\n            this._ariaDescriber.removeDescription(content, oldDescription);\r\n        }\r\n        if (newDescription) {\r\n            this._ariaDescriber.describe(content, newDescription);\r\n        }\r\n    }\r\n    /**\r\n     * Adds css theme class given the color to the component host\r\n     * @private\r\n     * @param {?} colorPalette\r\n     * @return {?}\r\n     */\r\n    _setColor(colorPalette) {\r\n        if (colorPalette !== this._color) {\r\n            if (this._color) {\r\n                this._elementRef.nativeElement.classList.remove(`mat-badge-${this._color}`);\r\n            }\r\n            if (colorPalette) {\r\n                this._elementRef.nativeElement.classList.add(`mat-badge-${colorPalette}`);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Clears any existing badges that might be left over from server-side rendering.\r\n     * @private\r\n     * @param {?} cssClass\r\n     * @return {?}\r\n     */\r\n    _clearExistingBadges(cssClass) {\r\n        /** @type {?} */\r\n        const element = this._elementRef.nativeElement;\r\n        /** @type {?} */\r\n        let childCount = element.children.length;\r\n        // Use a reverse while, because we'll be removing elements from the list as we're iterating.\r\n        while (childCount--) {\r\n            /** @type {?} */\r\n            const currentChild = element.children[childCount];\r\n            if (currentChild.classList.contains(cssClass)) {\r\n                element.removeChild(currentChild);\r\n            }\r\n        }\r\n    }\r\n}\r\nMatBadge.decorators = [\r\n    { type: Directive, args: [{\r\n                selector: '[matBadge]',\r\n                inputs: ['disabled: matBadgeDisabled'],\r\n                host: {\r\n                    'class': 'mat-badge',\r\n                    '[class.mat-badge-overlap]': 'overlap',\r\n                    '[class.mat-badge-above]': 'isAbove()',\r\n                    '[class.mat-badge-below]': '!isAbove()',\r\n                    '[class.mat-badge-before]': '!isAfter()',\r\n                    '[class.mat-badge-after]': 'isAfter()',\r\n                    '[class.mat-badge-small]': 'size === \"small\"',\r\n                    '[class.mat-badge-medium]': 'size === \"medium\"',\r\n                    '[class.mat-badge-large]': 'size === \"large\"',\r\n                    '[class.mat-badge-hidden]': 'hidden || !_hasContent',\r\n                    '[class.mat-badge-disabled]': 'disabled',\r\n                },\r\n            },] }\r\n];\r\n/** @nocollapse */\r\nMatBadge.ctorParameters = () => [\r\n    { type: NgZone },\r\n    { type: ElementRef },\r\n    { type: AriaDescriber },\r\n    { type: Renderer2 },\r\n    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [ANIMATION_MODULE_TYPE,] }] }\r\n];\r\nMatBadge.propDecorators = {\r\n    color: [{ type: Input, args: ['matBadgeColor',] }],\r\n    overlap: [{ type: Input, args: ['matBadgeOverlap',] }],\r\n    position: [{ type: Input, args: ['matBadgePosition',] }],\r\n    content: [{ type: Input, args: ['matBadge',] }],\r\n    description: [{ type: Input, args: ['matBadgeDescription',] }],\r\n    size: [{ type: Input, args: ['matBadgeSize',] }],\r\n    hidden: [{ type: Input, args: ['matBadgeHidden',] }]\r\n};\r\nif (false) {\r\n    /** @type {?} */\r\n    MatBadge.ngAcceptInputType_disabled;\r\n    /** @type {?} */\r\n    MatBadge.ngAcceptInputType_hidden;\r\n    /** @type {?} */\r\n    MatBadge.ngAcceptInputType_overlap;\r\n    /**\r\n     * Whether the badge has any content.\r\n     * @type {?}\r\n     */\r\n    MatBadge.prototype._hasContent;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    MatBadge.prototype._color;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    MatBadge.prototype._overlap;\r\n    /**\r\n     * Position the badge should reside.\r\n     * Accepts any combination of 'above'|'below' and 'before'|'after'\r\n     * @type {?}\r\n     */\r\n    MatBadge.prototype.position;\r\n    /**\r\n     * The content for the badge\r\n     * @type {?}\r\n     */\r\n    MatBadge.prototype.content;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    MatBadge.prototype._description;\r\n    /**\r\n     * Size of the badge. Can be 'small', 'medium', or 'large'.\r\n     * @type {?}\r\n     */\r\n    MatBadge.prototype.size;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    MatBadge.prototype._hidden;\r\n    /**\r\n     * Unique id for the badge\r\n     * @type {?}\r\n     */\r\n    MatBadge.prototype._id;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    MatBadge.prototype._badgeElement;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    MatBadge.prototype._ngZone;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    MatBadge.prototype._elementRef;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    MatBadge.prototype._ariaDescriber;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    MatBadge.prototype._renderer;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    MatBadge.prototype._animationMode;\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: src/material/badge/badge-module.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nclass MatBadgeModule {\r\n}\r\nMatBadgeModule.decorators = [\r\n    { type: NgModule, args: [{\r\n                imports: [\r\n                    A11yModule,\r\n                    MatCommonModule\r\n                ],\r\n                exports: [MatBadge],\r\n                declarations: [MatBadge],\r\n            },] }\r\n];\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: src/material/badge/public-api.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * Generated bundle index. Do not edit.\r\n */\r\n\r\nexport { MatBadge, MatBadgeModule };\r\n\r\n"]}