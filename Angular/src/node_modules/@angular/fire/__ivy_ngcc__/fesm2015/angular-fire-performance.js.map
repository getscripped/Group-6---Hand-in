{"version":3,"sources":["C:/Users/Celin/370finaal/gradus/node_modules/@angular/fire/fesm2015/angular-fire-performance.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4CC,mTAKC;;;;;;;;;;;;;;;;;;;;;;;;;;;;kCASgW;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAsQjW,gLAKC;;;;;;;;;;;+EAKsQ;;;;;;;;;;;;;;;;;;;;;;;;;CAuBvQ,8SAKC;;;;;;;;;;;;;kCAKA","file":"angular-fire-performance.js","sourcesContent":["import { InjectionToken, Injectable, Optional, Inject, NgZone, PLATFORM_ID, ɵɵdefineInjectable, ɵɵinject, ApplicationRef, NgModule } from '@angular/core';\nimport { of, EMPTY, Observable } from 'rxjs';\nimport { switchMap, map, tap, shareReplay, first } from 'rxjs/operators';\nimport { ɵlazySDKProxy, FirebaseApp } from '@angular/fire';\nimport { isPlatformBrowser } from '@angular/common';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// SEMVER @ v6, drop and move core ng metrics to a service\n/** @type {?} */\nconst AUTOMATICALLY_TRACE_CORE_NG_METRICS = new InjectionToken('angularfire2.performance.auto_trace');\n/** @type {?} */\nconst INSTRUMENTATION_ENABLED = new InjectionToken('angularfire2.performance.instrumentationEnabled');\n/** @type {?} */\nconst DATA_COLLECTION_ENABLED = new InjectionToken('angularfire2.performance.dataCollectionEnabled');\n// WARNING: interface has both a type and a value, skipping emit\nclass AngularFirePerformance {\n    /**\n     * @param {?} app\n     * @param {?} instrumentationEnabled\n     * @param {?} dataCollectionEnabled\n     * @param {?} zone\n     * @param {?} platformId\n     */\n    constructor(app, instrumentationEnabled, dataCollectionEnabled, zone, \n    // tslint:disable-next-line:ban-types\n    platformId) {\n        this.zone = zone;\n        this.performance = of(undefined).pipe(switchMap((/**\n         * @return {?}\n         */\n        () => isPlatformBrowser(platformId) ? zone.runOutsideAngular((/**\n         * @return {?}\n         */\n        () => import('firebase/performance'))) : EMPTY)), map((/**\n         * @return {?}\n         */\n        () => zone.runOutsideAngular((/**\n         * @return {?}\n         */\n        () => app.performance())))), tap((/**\n         * @param {?} performance\n         * @return {?}\n         */\n        performance => {\n            if (instrumentationEnabled !== true) {\n                performance.instrumentationEnabled = false;\n            }\n            if (dataCollectionEnabled !== true) {\n                performance.dataCollectionEnabled = false;\n            }\n        })), shareReplay({ bufferSize: 1, refCount: false }));\n        return ɵlazySDKProxy(this, this.performance, zone);\n    }\n}\nAngularFirePerformance.decorators = [\n    { type: Injectable, args: [{\n                providedIn: 'any'\n            },] }\n];\n/** @nocollapse */\nAngularFirePerformance.ctorParameters = () => [\n    { type: FirebaseApp },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [INSTRUMENTATION_ENABLED,] }] },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DATA_COLLECTION_ENABLED,] }] },\n    { type: NgZone },\n    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }\n];\n/** @nocollapse */ AngularFirePerformance.ɵprov = ɵɵdefineInjectable({ factory: function AngularFirePerformance_Factory() { return new AngularFirePerformance(ɵɵinject(FirebaseApp), ɵɵinject(INSTRUMENTATION_ENABLED, 8), ɵɵinject(DATA_COLLECTION_ENABLED, 8), ɵɵinject(NgZone), ɵɵinject(PLATFORM_ID)); }, token: AngularFirePerformance, providedIn: \"any\" });\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    AngularFirePerformance.prototype.performance;\n    /**\n     * @type {?}\n     * @private\n     */\n    AngularFirePerformance.prototype.zone;\n}\n/** @type {?} */\nconst trace$ = (/**\n * @param {?} traceId\n * @return {?}\n */\n(traceId) => {\n    if (typeof window !== 'undefined' && window.performance) {\n        /** @type {?} */\n        const entries = window.performance.getEntriesByName(traceId, 'measure') || [];\n        /** @type {?} */\n        const startMarkName = `_${traceId}Start[${entries.length}]`;\n        /** @type {?} */\n        const endMarkName = `_${traceId}End[${entries.length}]`;\n        return new Observable((/**\n         * @param {?} emitter\n         * @return {?}\n         */\n        emitter => {\n            window.performance.mark(startMarkName);\n            emitter.next();\n            return {\n                unsubscribe: (/**\n                 * @return {?}\n                 */\n                () => {\n                    window.performance.mark(endMarkName);\n                    window.performance.measure(traceId, startMarkName, endMarkName);\n                })\n            };\n        }));\n    }\n    else {\n        return EMPTY;\n    }\n});\nconst ɵ0 = trace$;\n/** @type {?} */\nconst traceUntil = (/**\n * @template T\n * @param {?} name\n * @param {?} test\n * @param {?=} options\n * @return {?}\n */\n(name, test, options) => (/**\n * @param {?} source$\n * @return {?}\n */\n(source$) => new Observable((/**\n * @param {?} subscriber\n * @return {?}\n */\nsubscriber => {\n    /** @type {?} */\n    const traceSubscription = trace$(name).subscribe();\n    return source$.pipe(tap((/**\n     * @param {?} a\n     * @return {?}\n     */\n    a => test(a) && traceSubscription.unsubscribe()), (/**\n     * @return {?}\n     */\n    () => {\n    }), (/**\n     * @return {?}\n     */\n    () => options && options.orComplete && traceSubscription.unsubscribe()))).subscribe(subscriber);\n}))));\n/** @type {?} */\nconst traceWhile = (/**\n * @template T\n * @param {?} name\n * @param {?} test\n * @param {?=} options\n * @return {?}\n */\n(name, test, options) => (/**\n * @param {?} source$\n * @return {?}\n */\n(source$) => new Observable((/**\n * @param {?} subscriber\n * @return {?}\n */\nsubscriber => {\n    /** @type {?} */\n    let traceSubscription;\n    return source$.pipe(tap((/**\n     * @param {?} a\n     * @return {?}\n     */\n    a => {\n        if (test(a)) {\n            traceSubscription = traceSubscription || trace$(name).subscribe();\n        }\n        else {\n            if (traceSubscription) {\n                traceSubscription.unsubscribe();\n            }\n            traceSubscription = undefined;\n        }\n    }), (/**\n     * @return {?}\n     */\n    () => {\n    }), (/**\n     * @return {?}\n     */\n    () => options && options.orComplete && traceSubscription && traceSubscription.unsubscribe()))).subscribe(subscriber);\n}))));\n/** @type {?} */\nconst traceUntilComplete = (/**\n * @template T\n * @param {?} name\n * @return {?}\n */\n(name) => (/**\n * @param {?} source$\n * @return {?}\n */\n(source$) => new Observable((/**\n * @param {?} subscriber\n * @return {?}\n */\nsubscriber => {\n    /** @type {?} */\n    const traceSubscription = trace$(name).subscribe();\n    return source$.pipe(tap((/**\n     * @return {?}\n     */\n    () => {\n    }), (/**\n     * @return {?}\n     */\n    () => {\n    }), (/**\n     * @return {?}\n     */\n    () => traceSubscription.unsubscribe()))).subscribe(subscriber);\n}))));\n/** @type {?} */\nconst traceUntilFirst = (/**\n * @template T\n * @param {?} name\n * @return {?}\n */\n(name) => (/**\n * @param {?} source$\n * @return {?}\n */\n(source$) => new Observable((/**\n * @param {?} subscriber\n * @return {?}\n */\nsubscriber => {\n    /** @type {?} */\n    const traceSubscription = trace$(name).subscribe();\n    return source$.pipe(tap((/**\n     * @return {?}\n     */\n    () => traceSubscription.unsubscribe()), (/**\n     * @return {?}\n     */\n    () => {\n    }), (/**\n     * @return {?}\n     */\n    () => {\n    }))).subscribe(subscriber);\n}))));\n/** @type {?} */\nconst trace = (/**\n * @template T\n * @param {?} name\n * @return {?}\n */\n(name) => (/**\n * @param {?} source$\n * @return {?}\n */\n(source$) => new Observable((/**\n * @param {?} subscriber\n * @return {?}\n */\nsubscriber => {\n    /** @type {?} */\n    const traceSubscription = trace$(name).subscribe();\n    return source$.pipe(tap((/**\n     * @return {?}\n     */\n    () => traceSubscription.unsubscribe()), (/**\n     * @return {?}\n     */\n    () => {\n    }), (/**\n     * @return {?}\n     */\n    () => traceSubscription.unsubscribe()))).subscribe(subscriber);\n}))));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst IS_STABLE_START_MARK = '_isStableStart';\n/** @type {?} */\nconst IS_STABLE_END_MARK = '_isStableEnd';\n/**\n * @return {?}\n */\nfunction markStarts() {\n    if (typeof (window) !== 'undefined' && window.performance) {\n        window.performance.mark(IS_STABLE_START_MARK);\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n/** @type {?} */\nconst started = markStarts();\nclass PerformanceMonitoringService {\n    /**\n     * @param {?} appRef\n     */\n    constructor(appRef) {\n        if (started) {\n            this.disposable = appRef.isStable.pipe(first((/**\n             * @param {?} it\n             * @return {?}\n             */\n            it => it)), tap((/**\n             * @return {?}\n             */\n            () => {\n                window.performance.mark(IS_STABLE_END_MARK);\n                window.performance.measure('isStable', IS_STABLE_START_MARK, IS_STABLE_END_MARK);\n            }))).subscribe();\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        if (this.disposable) {\n            this.disposable.unsubscribe();\n        }\n    }\n}\nPerformanceMonitoringService.decorators = [\n    { type: Injectable, args: [{\n                providedIn: 'any'\n            },] }\n];\n/** @nocollapse */\nPerformanceMonitoringService.ctorParameters = () => [\n    { type: ApplicationRef }\n];\n/** @nocollapse */ PerformanceMonitoringService.ɵprov = ɵɵdefineInjectable({ factory: function PerformanceMonitoringService_Factory() { return new PerformanceMonitoringService(ɵɵinject(ApplicationRef)); }, token: PerformanceMonitoringService, providedIn: \"any\" });\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    PerformanceMonitoringService.prototype.disposable;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass AngularFirePerformanceModule {\n    /**\n     * @param {?} perf\n     * @param {?} _\n     */\n    constructor(perf, _) {\n        // call anything here to get perf loading\n        // tslint:disable-next-line:no-unused-expression\n        perf.dataCollectionEnabled;\n    }\n}\nAngularFirePerformanceModule.decorators = [\n    { type: NgModule, args: [{\n                providers: [AngularFirePerformance]\n            },] }\n];\n/** @nocollapse */\nAngularFirePerformanceModule.ctorParameters = () => [\n    { type: AngularFirePerformance },\n    { type: PerformanceMonitoringService, decorators: [{ type: Optional }] }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { AUTOMATICALLY_TRACE_CORE_NG_METRICS, AngularFirePerformance, AngularFirePerformanceModule, DATA_COLLECTION_ENABLED, INSTRUMENTATION_ENABLED, PerformanceMonitoringService, trace, traceUntil, traceUntilComplete, traceUntilFirst, traceWhile };\n"]}