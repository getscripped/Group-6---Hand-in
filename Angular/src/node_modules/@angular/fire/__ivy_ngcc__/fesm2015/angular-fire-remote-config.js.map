{"version":3,"sources":["C:/Users/Celin/370finaal/gradus/node_modules/@angular/fire/fesm2015/angular-fire-remote-config.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAcA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA+SC,6TAKC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kCAU2W;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAuJ5W;;;;;;0BAKC","file":"angular-fire-remote-config.js","sourcesContent":["import { InjectionToken, Injectable, Inject, Optional, NgZone, PLATFORM_ID, ɵɵdefineInjectable, ɵɵinject, NgModule } from '@angular/core';\nimport { pipe, of, EMPTY, concat, Observable } from 'rxjs';\nimport { map, distinctUntilChanged, filter, withLatestFrom, scan, observeOn, switchMap, tap, startWith, shareReplay, groupBy, mergeMap, debounceTime } from 'rxjs/operators';\nimport { ɵAngularFireSchedulers, ɵfirebaseAppFactory, ɵkeepUnstableUntilFirstFactory, ɵlazySDKProxy, FIREBASE_OPTIONS, FIREBASE_APP_NAME } from '@angular/fire';\nimport 'firebase/app';\nimport { isPlatformBrowser } from '@angular/common';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @record\n */\nfunction ConfigTemplate() { }\n/** @type {?} */\nconst SETTINGS = new InjectionToken('angularfire2.remoteConfig.settings');\n/** @type {?} */\nconst DEFAULTS = new InjectionToken('angularfire2.remoteConfig.defaultConfig');\n// WARNING: interface has both a type and a value, skipping emit\n/** @type {?} */\nconst AS_TO_FN = { strings: 'asString', numbers: 'asNumber', booleans: 'asBoolean' };\n/** @type {?} */\nconst STATIC_VALUES = { numbers: 0, booleans: false, strings: undefined };\n// TODO look into the types here, I don't like the anys\n/** @type {?} */\nconst proxyAll = (/**\n * @param {?} observable\n * @param {?} as\n * @return {?}\n */\n(observable, as) => (/** @type {?} */ (new Proxy(observable.pipe(mapToObject((/** @type {?} */ (as)))), {\n    get: (/**\n     * @param {?} self\n     * @param {?} name\n     * @return {?}\n     */\n    (self, name) => self[name] || observable.pipe(map((/**\n     * @param {?} all\n     * @return {?}\n     */\n    all => all.find((/**\n     * @param {?} p\n     * @return {?}\n     */\n    p => p.key === name)))), map((/**\n     * @param {?} param\n     * @return {?}\n     */\n    param => param ? param[AS_TO_FN[as]]() : STATIC_VALUES[as])), distinctUntilChanged()))\n}))));\nconst ɵ0 = proxyAll;\n// TODO export as implements Partial<...> so minor doesn't break us\nclass Value {\n    // tslint:disable-next-line:variable-name\n    /**\n     * @param {?} _source\n     * @param {?} _value\n     */\n    constructor(_source, _value) {\n        this._source = _source;\n        this._value = _value;\n    }\n    /**\n     * @return {?}\n     */\n    asBoolean() {\n        return ['1', 'true', 't', 'y', 'yes', 'on'].indexOf(this._value.toLowerCase()) > -1;\n    }\n    /**\n     * @return {?}\n     */\n    asString() {\n        return this._value;\n    }\n    /**\n     * @return {?}\n     */\n    asNumber() {\n        return Number(this._value) || 0;\n    }\n    /**\n     * @return {?}\n     */\n    getSource() {\n        return this._source;\n    }\n}\nif (false) {\n    /** @type {?} */\n    Value.prototype._source;\n    /** @type {?} */\n    Value.prototype._value;\n}\n// SEMVER use ConstructorParameters when we can support Typescript 3.6\nclass Parameter extends Value {\n    /**\n     * @param {?} key\n     * @param {?} fetchTimeMillis\n     * @param {?} source\n     * @param {?} value\n     */\n    constructor(key, fetchTimeMillis, source, value) {\n        super(source, value);\n        this.key = key;\n        this.fetchTimeMillis = fetchTimeMillis;\n    }\n}\nif (false) {\n    /** @type {?} */\n    Parameter.prototype.key;\n    /** @type {?} */\n    Parameter.prototype.fetchTimeMillis;\n}\n// If it's a Parameter array, test any, else test the individual Parameter\n/** @type {?} */\nconst filterTest = (/**\n * @param {?} fn\n * @return {?}\n */\n(fn) => filter((/**\n * @param {?} it\n * @return {?}\n */\nit => Array.isArray(it) ? it.some(fn) : fn(it))));\nconst ɵ1 = filterTest;\n// Allow the user to bypass the default values and wait till they get something from the server, even if it's a cached copy;\n// if used in conjuntion with first() it will only fetch RC values from the server if they aren't cached locally\n/** @type {?} */\nconst filterRemote = (/**\n * @return {?}\n */\n() => filterTest((/**\n * @param {?} p\n * @return {?}\n */\np => p.getSource() === 'remote')));\n// filterFresh allows the developer to effectively set up a maximum cache time\n/** @type {?} */\nconst filterFresh = (/**\n * @param {?} howRecentInMillis\n * @return {?}\n */\n(howRecentInMillis) => filterTest((/**\n * @param {?} p\n * @return {?}\n */\np => p.fetchTimeMillis + howRecentInMillis >= new Date().getTime())));\n// I ditched loading the defaults into RC and a simple map for scan since we already have our own defaults implementation.\n// The idea here being that if they have a default that never loads from the server, they will be able to tell via fetchTimeMillis\n// on the Parameter. Also if it doesn't come from the server it won't emit again in .changes, due to the distinctUntilChanged,\n// which we can simplify to === rather than deep comparison\n/** @type {?} */\nconst scanToParametersArray = (/**\n * @param {?} remoteConfig\n * @return {?}\n */\n(remoteConfig) => pipe(withLatestFrom(remoteConfig), scan((/**\n * @param {?} existing\n * @param {?} __1\n * @return {?}\n */\n(existing, [all, rc]) => {\n    // SEMVER use \"new Set\" to unique once we're only targeting es6\n    // at the scale we expect remote config to be at, we probably won't see a performance hit from this unoptimized uniqueness\n    // implementation.\n    // const allKeys = [...new Set([...existing.map(p => p.key), ...Object.keys(all)])];\n    /** @type {?} */\n    const allKeys = [...existing.map((/**\n         * @param {?} p\n         * @return {?}\n         */\n        p => p.key)), ...Object.keys(all)].filter((/**\n     * @param {?} v\n     * @param {?} i\n     * @param {?} a\n     * @return {?}\n     */\n    (v, i, a) => a.indexOf(v) === i));\n    return allKeys.map((/**\n     * @param {?} key\n     * @return {?}\n     */\n    key => {\n        /** @type {?} */\n        const updatedValue = all[key];\n        return updatedValue ? new Parameter(key, rc ? rc.fetchTimeMillis : -1, updatedValue.getSource(), updatedValue.asString())\n            : existing.find((/**\n             * @param {?} p\n             * @return {?}\n             */\n            p => p.key === key));\n    }));\n}), (/** @type {?} */ ([])))));\nconst ɵ2 = scanToParametersArray;\nclass AngularFireRemoteConfig {\n    /**\n     * @param {?} options\n     * @param {?} nameOrConfig\n     * @param {?} settings\n     * @param {?} defaultConfig\n     * @param {?} zone\n     * @param {?} platformId\n     */\n    constructor(options, nameOrConfig, settings, defaultConfig, zone, \n    // tslint:disable-next-line:ban-types\n    platformId) {\n        this.zone = zone;\n        /** @type {?} */\n        const schedulers = new ɵAngularFireSchedulers(zone);\n        /** @type {?} */\n        const remoteConfig$ = of(undefined).pipe(observeOn(schedulers.outsideAngular), switchMap((/**\n         * @return {?}\n         */\n        () => isPlatformBrowser(platformId) ? import('firebase/remote-config') : EMPTY)), map((/**\n         * @return {?}\n         */\n        () => ɵfirebaseAppFactory(options, zone, nameOrConfig))), map((/**\n         * @param {?} app\n         * @return {?}\n         */\n        app => app.remoteConfig())), tap((/**\n         * @param {?} rc\n         * @return {?}\n         */\n        rc => {\n            if (settings) {\n                rc.settings = settings;\n            }\n            if (defaultConfig) {\n                rc.defaultConfig = defaultConfig;\n            }\n        })), \n        // tslint:disable-next-line\n        startWith(undefined), shareReplay({ bufferSize: 1, refCount: false }));\n        /** @type {?} */\n        const loadedRemoteConfig$ = remoteConfig$.pipe(filter((/**\n         * @param {?} rc\n         * @return {?}\n         */\n        rc => !!rc)));\n        /** @type {?} */\n        const default$ = of(Object.keys(defaultConfig || {}).reduce((/**\n         * @param {?} c\n         * @param {?} k\n         * @return {?}\n         */\n        (c, k) => (Object.assign(Object.assign({}, c), { [k]: new Value('default', defaultConfig[k].toString()) }))), {}));\n        // we should filter out the defaults we provided to RC, since we have our own implementation\n        // that gives us a -1 for fetchTimeMillis (so filterFresh can filter them out)\n        /** @type {?} */\n        const filterOutDefaults = map((/**\n         * @param {?} all\n         * @return {?}\n         */\n        all => Object.keys(all)\n            .filter((/**\n         * @param {?} key\n         * @return {?}\n         */\n        key => all[key].getSource() !== 'default'))\n            .reduce((/**\n         * @param {?} acc\n         * @param {?} key\n         * @return {?}\n         */\n        (acc, key) => (Object.assign(Object.assign({}, acc), { [key]: all[key] }))), {})));\n        /** @type {?} */\n        const existing$ = loadedRemoteConfig$.pipe(switchMap((/**\n         * @param {?} rc\n         * @return {?}\n         */\n        rc => rc.activate()\n            .then((/**\n         * @return {?}\n         */\n        () => rc.ensureInitialized()))\n            .then((/**\n         * @return {?}\n         */\n        () => rc.getAll())))), filterOutDefaults);\n        /** @type {?} */\n        const fresh$ = loadedRemoteConfig$.pipe(switchMap((/**\n         * @param {?} rc\n         * @return {?}\n         */\n        rc => zone.runOutsideAngular((/**\n         * @return {?}\n         */\n        () => rc.fetchAndActivate()\n            .then((/**\n         * @return {?}\n         */\n        () => rc.ensureInitialized()))\n            .then((/**\n         * @return {?}\n         */\n        () => rc.getAll())))))), filterOutDefaults);\n        this.parameters = concat(default$, existing$, fresh$).pipe(scanToParametersArray(remoteConfig$), ɵkeepUnstableUntilFirstFactory(schedulers), shareReplay({ bufferSize: 1, refCount: true }));\n        this.changes = this.parameters.pipe(switchMap((/**\n         * @param {?} params\n         * @return {?}\n         */\n        params => of(...params))), groupBy((/**\n         * @param {?} param\n         * @return {?}\n         */\n        param => param.key)), mergeMap((/**\n         * @param {?} group\n         * @return {?}\n         */\n        group => group.pipe(distinctUntilChanged()))));\n        this.strings = proxyAll(this.parameters, 'strings');\n        this.booleans = proxyAll(this.parameters, 'booleans');\n        this.numbers = proxyAll(this.parameters, 'numbers');\n        return ɵlazySDKProxy(this, loadedRemoteConfig$, zone);\n    }\n}\nAngularFireRemoteConfig.decorators = [\n    { type: Injectable, args: [{\n                providedIn: 'any'\n            },] }\n];\n/** @nocollapse */\nAngularFireRemoteConfig.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [FIREBASE_OPTIONS,] }] },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [FIREBASE_APP_NAME,] }] },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [SETTINGS,] }] },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DEFAULTS,] }] },\n    { type: NgZone },\n    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }\n];\n/** @nocollapse */ AngularFireRemoteConfig.ɵprov = ɵɵdefineInjectable({ factory: function AngularFireRemoteConfig_Factory() { return new AngularFireRemoteConfig(ɵɵinject(FIREBASE_OPTIONS), ɵɵinject(FIREBASE_APP_NAME, 8), ɵɵinject(SETTINGS, 8), ɵɵinject(DEFAULTS, 8), ɵɵinject(NgZone), ɵɵinject(PLATFORM_ID)); }, token: AngularFireRemoteConfig, providedIn: \"any\" });\nif (false) {\n    /** @type {?} */\n    AngularFireRemoteConfig.prototype.changes;\n    /** @type {?} */\n    AngularFireRemoteConfig.prototype.parameters;\n    /** @type {?} */\n    AngularFireRemoteConfig.prototype.numbers;\n    /** @type {?} */\n    AngularFireRemoteConfig.prototype.booleans;\n    /** @type {?} */\n    AngularFireRemoteConfig.prototype.strings;\n    /**\n     * @type {?}\n     * @private\n     */\n    AngularFireRemoteConfig.prototype.zone;\n}\n/** @type {?} */\nconst budget = (/**\n * @template T\n * @param {?} interval\n * @return {?}\n */\n(interval) => (/**\n * @param {?} source\n * @return {?}\n */\n(source) => new Observable((/**\n * @param {?} observer\n * @return {?}\n */\nobserver => {\n    /** @type {?} */\n    let timedOut = false;\n    // TODO use scheduler task rather than settimeout\n    /** @type {?} */\n    const timeout = setTimeout((/**\n     * @return {?}\n     */\n    () => {\n        observer.complete();\n        timedOut = true;\n    }), interval);\n    return source.subscribe({\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        next(val) {\n            if (!timedOut) {\n                observer.next(val);\n            }\n        },\n        /**\n         * @param {?} err\n         * @return {?}\n         */\n        error(err) {\n            if (!timedOut) {\n                clearTimeout(timeout);\n                observer.error(err);\n            }\n        },\n        /**\n         * @return {?}\n         */\n        complete() {\n            if (!timedOut) {\n                clearTimeout(timeout);\n                observer.complete();\n            }\n        }\n    });\n}))));\n/** @type {?} */\nconst typedMethod = (/**\n * @param {?} it\n * @return {?}\n */\n(it) => {\n    switch (typeof it) {\n        case 'string':\n            return 'asString';\n        case 'boolean':\n            return 'asBoolean';\n        case 'number':\n            return 'asNumber';\n        default:\n            return 'asString';\n    }\n});\nconst ɵ3 = typedMethod;\n/**\n * @template T\n * @param {?=} to\n * @return {?}\n */\nfunction scanToObject(to = 'strings') {\n    return pipe(\n    // TODO cleanup\n    scan((/**\n     * @param {?} c\n     * @param {?} p\n     * @return {?}\n     */\n    (c, p) => (Object.assign(Object.assign({}, c), { [p.key]: typeof to === 'object' ?\n            p[typedMethod(to[p.key])]() :\n            p[AS_TO_FN[to]]() }))), typeof to === 'object' ?\n        (/** @type {?} */ (to)) :\n        (/** @type {?} */ ({}))), debounceTime(1), budget(10), distinctUntilChanged((/**\n     * @param {?} a\n     * @param {?} b\n     * @return {?}\n     */\n    (a, b) => JSON.stringify(a) === JSON.stringify(b))));\n}\n/**\n * @template T\n * @param {?=} to\n * @return {?}\n */\nfunction mapToObject(to = 'strings') {\n    return pipe(\n    // TODO this is getting a little long, cleanup\n    map((/**\n     * @param {?} params\n     * @return {?}\n     */\n    (params) => params.reduce((/**\n     * @param {?} c\n     * @param {?} p\n     * @return {?}\n     */\n    (c, p) => (Object.assign(Object.assign({}, c), { [p.key]: typeof to === 'object' ?\n            p[typedMethod(to[p.key])]() :\n            p[AS_TO_FN[to]]() }))), typeof to === 'object' ?\n        (/** @type {?} */ (to)) :\n        (/** @type {?} */ ({}))))), distinctUntilChanged((/**\n     * @param {?} a\n     * @param {?} b\n     * @return {?}\n     */\n    (a, b) => JSON.stringify(a) === JSON.stringify(b))));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass AngularFireRemoteConfigModule {\n}\nAngularFireRemoteConfigModule.decorators = [\n    { type: NgModule, args: [{\n                providers: [AngularFireRemoteConfig]\n            },] }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { AngularFireRemoteConfig, AngularFireRemoteConfigModule, DEFAULTS, Parameter, SETTINGS, Value, budget, filterFresh, filterRemote, mapToObject, scanToObject };\n"]}