{"version":3,"sources":["C:/Users/Celin/370finaal/gradus/node_modules/@angular/fire/fesm2015/angular-fire-analytics.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;AAgBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAuIC,2ZAKC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2DAaib;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6Qlb,iZAKC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sFAYmZ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAqDpZ,kNAKC;;;;;;;;;;;;;;;;kCAOiR;;;;;;;;;;;;;;;;;;;;;;;;;;CAwBlR,sUAKC;;;;;;;;;;;;;;;;kCAMA","file":"angular-fire-analytics.js","sourcesContent":["import { __awaiter } from 'tslib';\nimport { InjectionToken, Injectable, Inject, Optional, PLATFORM_ID, NgZone, ɵɵdefineInjectable, ɵɵinject, NgModuleFactory, ComponentFactoryResolver, Injector, INJECTOR, NgModule } from '@angular/core';\nimport { of, EMPTY, Observable, from } from 'rxjs';\nimport { isPlatformBrowser, isPlatformServer } from '@angular/common';\nimport { observeOn, switchMap, map, tap, shareReplay, filter, withLatestFrom, groupBy, mergeMap, startWith, pairwise } from 'rxjs/operators';\nimport { ɵAngularFireSchedulers, ɵfirebaseAppFactory, ɵlazySDKProxy, FIREBASE_OPTIONS, FIREBASE_APP_NAME } from '@angular/fire';\nimport { ActivationEnd, NavigationEnd, ROUTES, Router } from '@angular/router';\nimport { Title } from '@angular/platform-browser';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @record\n */\nfunction Config() { }\n/** @type {?} */\nconst COLLECTION_ENABLED = new InjectionToken('angularfire2.analytics.analyticsCollectionEnabled');\n/** @type {?} */\nconst APP_VERSION = new InjectionToken('angularfire2.analytics.appVersion');\n/** @type {?} */\nconst APP_NAME = new InjectionToken('angularfire2.analytics.appName');\n/** @type {?} */\nconst DEBUG_MODE = new InjectionToken('angularfire2.analytics.debugMode');\n/** @type {?} */\nconst CONFIG = new InjectionToken('angularfire2.analytics.config');\n/** @type {?} */\nconst APP_NAME_KEY = 'app_name';\n/** @type {?} */\nconst APP_VERSION_KEY = 'app_version';\n/** @type {?} */\nconst DEBUG_MODE_KEY = 'debug_mode';\n/** @type {?} */\nconst ANALYTICS_ID_FIELD = 'measurementId';\n/** @type {?} */\nconst GTAG_CONFIG_COMMAND = 'config';\n/** @type {?} */\nconst GTAG_FUNCTION_NAME = 'gtag';\n/** @type {?} */\nconst DATA_LAYER_NAME = 'dataLayer';\n// WARNING: interface has both a type and a value, skipping emit\n/** @type {?} */\nlet gtag;\n/** @type {?} */\nlet analyticsInitialized;\n/** @type {?} */\nconst analyticsInstanceCache = {};\nclass AngularFireAnalytics {\n    /**\n     * @param {?} options\n     * @param {?} nameOrConfig\n     * @param {?} analyticsCollectionEnabled\n     * @param {?} providedAppVersion\n     * @param {?} providedAppName\n     * @param {?} debugModeEnabled\n     * @param {?} providedConfig\n     * @param {?} platformId\n     * @param {?} zone\n     */\n    constructor(options, nameOrConfig, analyticsCollectionEnabled, providedAppVersion, providedAppName, debugModeEnabled, providedConfig, \n    // tslint:disable-next-line:ban-types\n    platformId, zone) {\n        this.options = options;\n        if (!analyticsInitialized) {\n            if (isPlatformBrowser(platformId)) {\n                gtag = window[GTAG_FUNCTION_NAME] || ((/**\n                 * @param {...?} args\n                 * @return {?}\n                 */\n                (...args) => {\n                    window[DATA_LAYER_NAME].push(args);\n                }));\n                window[DATA_LAYER_NAME] = window[DATA_LAYER_NAME] || [];\n                analyticsInitialized = zone.runOutsideAngular((/**\n                 * @return {?}\n                 */\n                () => new Promise((/**\n                 * @param {?} resolve\n                 * @return {?}\n                 */\n                resolve => {\n                    window[GTAG_FUNCTION_NAME] = (/**\n                     * @param {...?} args\n                     * @return {?}\n                     */\n                    (...args) => {\n                        if (args[0] === 'js') {\n                            resolve();\n                        }\n                        gtag(...args);\n                    });\n                }))));\n            }\n            else {\n                gtag = (/**\n                 * @return {?}\n                 */\n                () => {\n                });\n                analyticsInitialized = Promise.resolve();\n            }\n        }\n        /** @type {?} */\n        let analytics = analyticsInstanceCache[options[ANALYTICS_ID_FIELD]];\n        if (!analytics) {\n            analytics = of(undefined).pipe(observeOn(new ɵAngularFireSchedulers(zone).outsideAngular), switchMap((/**\n             * @return {?}\n             */\n            () => isPlatformBrowser(platformId) ? import('firebase/analytics') : EMPTY)), map((/**\n             * @return {?}\n             */\n            () => ɵfirebaseAppFactory(options, zone, nameOrConfig))), map((/**\n             * @param {?} app\n             * @return {?}\n             */\n            app => app.analytics())), tap((/**\n             * @param {?} analytics\n             * @return {?}\n             */\n            analytics => {\n                if (analyticsCollectionEnabled === false) {\n                    analytics.setAnalyticsCollectionEnabled(false);\n                }\n            })), shareReplay({ bufferSize: 1, refCount: false }));\n            analyticsInstanceCache[options[ANALYTICS_ID_FIELD]] = analytics;\n        }\n        if (providedConfig) {\n            this.updateConfig(providedConfig);\n        }\n        if (providedAppName) {\n            this.updateConfig({ [APP_NAME_KEY]: providedAppName });\n        }\n        if (providedAppVersion) {\n            this.updateConfig({ [APP_VERSION_KEY]: providedAppVersion });\n        }\n        if (debugModeEnabled) {\n            this.updateConfig({ [DEBUG_MODE_KEY]: 1 });\n        }\n        return ɵlazySDKProxy(this, analytics, zone);\n    }\n    /**\n     * @param {?} config\n     * @return {?}\n     */\n    updateConfig(config) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield analyticsInitialized;\n            gtag(GTAG_CONFIG_COMMAND, this.options[ANALYTICS_ID_FIELD], Object.assign(Object.assign({}, config), { update: true }));\n        });\n    }\n}\nAngularFireAnalytics.decorators = [\n    { type: Injectable, args: [{\n                providedIn: 'any'\n            },] }\n];\n/** @nocollapse */\nAngularFireAnalytics.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [FIREBASE_OPTIONS,] }] },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [FIREBASE_APP_NAME,] }] },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [COLLECTION_ENABLED,] }] },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [APP_VERSION,] }] },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [APP_NAME,] }] },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DEBUG_MODE,] }] },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [CONFIG,] }] },\n    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },\n    { type: NgZone }\n];\n/** @nocollapse */ AngularFireAnalytics.ɵprov = ɵɵdefineInjectable({ factory: function AngularFireAnalytics_Factory() { return new AngularFireAnalytics(ɵɵinject(FIREBASE_OPTIONS), ɵɵinject(FIREBASE_APP_NAME, 8), ɵɵinject(COLLECTION_ENABLED, 8), ɵɵinject(APP_VERSION, 8), ɵɵinject(APP_NAME, 8), ɵɵinject(DEBUG_MODE, 8), ɵɵinject(CONFIG, 8), ɵɵinject(PLATFORM_ID), ɵɵinject(NgZone)); }, token: AngularFireAnalytics, providedIn: \"any\" });\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    AngularFireAnalytics.prototype.options;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst FIREBASE_EVENT_ORIGIN_KEY = 'firebase_event_origin';\n/** @type {?} */\nconst FIREBASE_PREVIOUS_SCREEN_CLASS_KEY = 'firebase_previous_class';\n/** @type {?} */\nconst FIREBASE_PREVIOUS_SCREEN_INSTANCE_ID_KEY = 'firebase_previous_id';\n/** @type {?} */\nconst FIREBASE_PREVIOUS_SCREEN_NAME_KEY = 'firebase_previous_screen';\n/** @type {?} */\nconst FIREBASE_SCREEN_CLASS_KEY = 'firebase_screen_class';\n/** @type {?} */\nconst FIREBASE_SCREEN_INSTANCE_ID_KEY = 'firebase_screen_id';\n/** @type {?} */\nconst FIREBASE_SCREEN_NAME_KEY = 'firebase_screen';\n/** @type {?} */\nconst OUTLET_KEY = 'outlet';\n/** @type {?} */\nconst PAGE_PATH_KEY = 'page_path';\n/** @type {?} */\nconst PAGE_TITLE_KEY = 'page_title';\n/** @type {?} */\nconst SCREEN_CLASS_KEY = 'screen_class';\n/** @type {?} */\nconst SCREEN_NAME_KEY = 'screen_name';\n/** @type {?} */\nconst SCREEN_VIEW_EVENT = 'screen_view';\n/** @type {?} */\nconst EVENT_ORIGIN_AUTO = 'auto';\n/** @type {?} */\nconst DEFAULT_SCREEN_CLASS = '???';\n/** @type {?} */\nconst NG_PRIMARY_OUTLET = 'primary';\n/** @type {?} */\nconst SCREEN_INSTANCE_DELIMITER = '#';\n/** @type {?} */\nconst ANNOTATIONS = '__annotations__';\n// this is an INT64 in iOS/Android but use INT32 cause javascript\n/** @type {?} */\nlet nextScreenInstanceID = Math.floor(Math.random() * (Math.pow(2, 32) - 1)) - Math.pow(2, 31);\n/** @type {?} */\nconst knownScreenInstanceIDs = {};\n/** @type {?} */\nconst getScreenInstanceID = (/**\n * @param {?} params\n * @return {?}\n */\n(params) => {\n    // unique the screen class against the outlet name\n    /** @type {?} */\n    const screenInstanceKey = [\n        params[SCREEN_CLASS_KEY],\n        params[OUTLET_KEY]\n    ].join(SCREEN_INSTANCE_DELIMITER);\n    if (knownScreenInstanceIDs.hasOwnProperty(screenInstanceKey)) {\n        return knownScreenInstanceIDs[screenInstanceKey];\n    }\n    else {\n        /** @type {?} */\n        const ret = nextScreenInstanceID++;\n        knownScreenInstanceIDs[screenInstanceKey] = ret;\n        return ret;\n    }\n});\nconst ɵ0 = getScreenInstanceID;\nclass ScreenTrackingService {\n    /**\n     * @param {?} analytics\n     * @param {?} router\n     * @param {?} title\n     * @param {?} componentFactoryResolver\n     * @param {?} platformId\n     * @param {?} debugModeEnabled\n     * @param {?} zone\n     * @param {?} injector\n     */\n    constructor(analytics, router, title, componentFactoryResolver, \n    // tslint:disable-next-line:ban-types\n    platformId, debugModeEnabled, zone, injector) {\n        if (!router || !isPlatformBrowser(platformId)) {\n            return this;\n        }\n        zone.runOutsideAngular((/**\n         * @return {?}\n         */\n        () => {\n            /** @type {?} */\n            const activationEndEvents = router.events.pipe(filter((/**\n             * @param {?} e\n             * @return {?}\n             */\n            e => e instanceof ActivationEnd)));\n            /** @type {?} */\n            const navigationEndEvents = router.events.pipe(filter((/**\n             * @param {?} e\n             * @return {?}\n             */\n            e => e instanceof NavigationEnd)));\n            this.disposable = navigationEndEvents.pipe(withLatestFrom(activationEndEvents), switchMap((/**\n             * @param {?} __0\n             * @return {?}\n             */\n            ([navigationEnd, activationEnd]) => {\n                // SEMVER: start using optional chains and nullish coalescing once we support newer typescript\n                /** @type {?} */\n                const pagePath = navigationEnd.url;\n                /** @type {?} */\n                const screenName = activationEnd.snapshot.routeConfig && activationEnd.snapshot.routeConfig.path || pagePath;\n                /** @type {?} */\n                const params = {\n                    [SCREEN_NAME_KEY]: screenName,\n                    [PAGE_PATH_KEY]: pagePath,\n                    [FIREBASE_EVENT_ORIGIN_KEY]: EVENT_ORIGIN_AUTO,\n                    [FIREBASE_SCREEN_NAME_KEY]: screenName,\n                    [OUTLET_KEY]: activationEnd.snapshot.outlet\n                };\n                if (title) {\n                    params[PAGE_TITLE_KEY] = title.getTitle();\n                }\n                /** @type {?} */\n                const component = activationEnd.snapshot.component;\n                /** @type {?} */\n                const routeConfig = activationEnd.snapshot.routeConfig;\n                /** @type {?} */\n                const loadChildren = routeConfig && routeConfig.loadChildren;\n                // TODO figure out how to handle minification\n                if (typeof loadChildren === 'string') {\n                    // SEMVER: this is the older lazy load style \"./path#ClassName\", drop this when we drop old ng\n                    // TODO is it worth seeing if I can look up the component factory selector from the module name?\n                    // it's lazy so it's not registered with componentFactoryResolver yet... seems a pain for a depreciated style\n                    return of(Object.assign(Object.assign({}, params), { [SCREEN_CLASS_KEY]: loadChildren.split('#')[1] }));\n                }\n                else if (typeof component === 'string') {\n                    return of(Object.assign(Object.assign({}, params), { [SCREEN_CLASS_KEY]: component }));\n                }\n                else if (component) {\n                    /** @type {?} */\n                    const componentFactory = componentFactoryResolver.resolveComponentFactory(component);\n                    return of(Object.assign(Object.assign({}, params), { [SCREEN_CLASS_KEY]: componentFactory.selector }));\n                }\n                else if (loadChildren) {\n                    /** @type {?} */\n                    const loadedChildren = loadChildren();\n                    /** @type {?} */\n                    const loadedChildren$ = (loadedChildren instanceof Observable) ?\n                        loadedChildren :\n                        from(Promise.resolve(loadedChildren));\n                    return loadedChildren$.pipe(map((/**\n                     * @param {?} lazyModule\n                     * @return {?}\n                     */\n                    lazyModule => {\n                        if (lazyModule instanceof NgModuleFactory) {\n                            // AOT create an injector\n                            /** @type {?} */\n                            const moduleRef = lazyModule.create(injector);\n                            // INVESTIGATE is this the right way to get at the matching route?\n                            /** @type {?} */\n                            const routes = moduleRef.injector.get(ROUTES);\n                            /** @type {?} */\n                            const component = routes[0][0].component;\n                            try {\n                                /** @type {?} */\n                                const componentFactory = moduleRef.componentFactoryResolver.resolveComponentFactory(component);\n                                return Object.assign(Object.assign({}, params), { [SCREEN_CLASS_KEY]: componentFactory.selector });\n                            }\n                            catch (_) {\n                                return Object.assign(Object.assign({}, params), { [SCREEN_CLASS_KEY]: DEFAULT_SCREEN_CLASS });\n                            }\n                        }\n                        else {\n                            // JIT look at the annotations\n                            // INVESTIGATE are there public APIs for this stuff?\n                            /** @type {?} */\n                            const declarations = [].concat.apply([], (lazyModule[ANNOTATIONS] || []).map((/**\n                             * @param {?} f\n                             * @return {?}\n                             */\n                            (f) => f.declarations)));\n                            /** @type {?} */\n                            const selectors = [].concat.apply([], declarations.map((/**\n                             * @param {?} c\n                             * @return {?}\n                             */\n                            (c) => (c[ANNOTATIONS] || []).map((/**\n                             * @param {?} f\n                             * @return {?}\n                             */\n                            (f) => f.selector)))));\n                            // should I just be grabbing the selector like this or should i match against the route component?\n                            //   const routerModule = lazyModule.ngInjectorDef.imports.find(i => i.ngModule && ....);\n                            //   const route = routerModule.providers[0].find(p => p.provide == ROUTES).useValue[0];\n                            return Object.assign(Object.assign({}, params), { [SCREEN_CLASS_KEY]: selectors[0] || DEFAULT_SCREEN_CLASS });\n                        }\n                    })));\n                }\n                else {\n                    return of(Object.assign(Object.assign({}, params), { [SCREEN_CLASS_KEY]: DEFAULT_SCREEN_CLASS }));\n                }\n            })), map((/**\n             * @param {?} params\n             * @return {?}\n             */\n            params => (Object.assign({ [FIREBASE_SCREEN_CLASS_KEY]: params[SCREEN_CLASS_KEY], [FIREBASE_SCREEN_INSTANCE_ID_KEY]: getScreenInstanceID(params) }, params)))), tap((/**\n             * @param {?} params\n             * @return {?}\n             */\n            params => {\n                // TODO perhaps I can be smarter about this, bubble events up to the nearest outlet?\n                if (params[OUTLET_KEY] === NG_PRIMARY_OUTLET) {\n                    analytics.setCurrentScreen(params[SCREEN_NAME_KEY]);\n                    analytics.updateConfig({\n                        [PAGE_PATH_KEY]: params[PAGE_PATH_KEY],\n                        [SCREEN_CLASS_KEY]: params[SCREEN_CLASS_KEY]\n                    });\n                    if (title) {\n                        analytics.updateConfig({ [PAGE_TITLE_KEY]: params[PAGE_TITLE_KEY] });\n                    }\n                }\n            })), groupBy((/**\n             * @param {?} params\n             * @return {?}\n             */\n            params => params[OUTLET_KEY])), \n            // tslint:disable-next-line\n            mergeMap((/**\n             * @param {?} group\n             * @return {?}\n             */\n            group => group.pipe(startWith(undefined), pairwise()))), map((/**\n             * @param {?} __0\n             * @return {?}\n             */\n            ([prior, current]) => prior ? Object.assign({ [FIREBASE_PREVIOUS_SCREEN_CLASS_KEY]: prior[SCREEN_CLASS_KEY], [FIREBASE_PREVIOUS_SCREEN_NAME_KEY]: prior[SCREEN_NAME_KEY], [FIREBASE_PREVIOUS_SCREEN_INSTANCE_ID_KEY]: prior[FIREBASE_SCREEN_INSTANCE_ID_KEY] }, current) : current)), \n            // tslint:disable-next-line:no-console\n            tap((/**\n             * @param {?} params\n             * @return {?}\n             */\n            params => debugModeEnabled && console.info(SCREEN_VIEW_EVENT, params))), tap((/**\n             * @param {?} params\n             * @return {?}\n             */\n            params => zone.runOutsideAngular((/**\n             * @return {?}\n             */\n            () => analytics.logEvent(SCREEN_VIEW_EVENT, params)))))).subscribe();\n        }));\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        if (this.disposable) {\n            this.disposable.unsubscribe();\n        }\n    }\n}\nScreenTrackingService.decorators = [\n    { type: Injectable, args: [{\n                providedIn: 'any'\n            },] }\n];\n/** @nocollapse */\nScreenTrackingService.ctorParameters = () => [\n    { type: AngularFireAnalytics },\n    { type: Router, decorators: [{ type: Optional }] },\n    { type: Title, decorators: [{ type: Optional }] },\n    { type: ComponentFactoryResolver },\n    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DEBUG_MODE,] }] },\n    { type: NgZone },\n    { type: Injector }\n];\n/** @nocollapse */ ScreenTrackingService.ɵprov = ɵɵdefineInjectable({ factory: function ScreenTrackingService_Factory() { return new ScreenTrackingService(ɵɵinject(AngularFireAnalytics), ɵɵinject(Router, 8), ɵɵinject(Title, 8), ɵɵinject(ComponentFactoryResolver), ɵɵinject(PLATFORM_ID), ɵɵinject(DEBUG_MODE, 8), ɵɵinject(NgZone), ɵɵinject(INJECTOR)); }, token: ScreenTrackingService, providedIn: \"any\" });\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    ScreenTrackingService.prototype.disposable;\n}\nclass UserTrackingService {\n    // TODO a user properties injector\n    /**\n     * @param {?} analytics\n     * @param {?} zone\n     * @param {?} platformId\n     */\n    constructor(analytics, zone, \n    // tslint:disable-next-line:ban-types\n    platformId) {\n        /** @type {?} */\n        const schedulers = new ɵAngularFireSchedulers(zone);\n        if (!isPlatformServer(platformId)) {\n            zone.runOutsideAngular((/**\n             * @return {?}\n             */\n            () => {\n                // @ts-ignore zap the import in the UMD\n                this.disposable = from(import('firebase/auth')).pipe(observeOn(schedulers.outsideAngular), switchMap((/**\n                 * @return {?}\n                 */\n                () => analytics.app)), map((/**\n                 * @param {?} app\n                 * @return {?}\n                 */\n                app => app.auth())), switchMap((/**\n                 * @param {?} auth\n                 * @return {?}\n                 */\n                auth => new Observable(auth.onAuthStateChanged.bind(auth)))), switchMap((/**\n                 * @param {?} user\n                 * @return {?}\n                 */\n                user => analytics.setUserId(user ? user.uid : null)))).subscribe();\n            }));\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        if (this.disposable) {\n            this.disposable.unsubscribe();\n        }\n    }\n}\nUserTrackingService.decorators = [\n    { type: Injectable, args: [{\n                providedIn: 'any'\n            },] }\n];\n/** @nocollapse */\nUserTrackingService.ctorParameters = () => [\n    { type: AngularFireAnalytics },\n    { type: NgZone },\n    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }\n];\n/** @nocollapse */ UserTrackingService.ɵprov = ɵɵdefineInjectable({ factory: function UserTrackingService_Factory() { return new UserTrackingService(ɵɵinject(AngularFireAnalytics), ɵɵinject(NgZone), ɵɵinject(PLATFORM_ID)); }, token: UserTrackingService, providedIn: \"any\" });\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    UserTrackingService.prototype.disposable;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass AngularFireAnalyticsModule {\n    /**\n     * @param {?} analytics\n     * @param {?} screenTracking\n     * @param {?} userTracking\n     */\n    constructor(analytics, screenTracking, userTracking) {\n        // calling anything on analytics will eagerly load the SDK\n        // tslint:disable-next-line:no-unused-expression\n        analytics.app;\n    }\n}\nAngularFireAnalyticsModule.decorators = [\n    { type: NgModule, args: [{\n                providers: [AngularFireAnalytics]\n            },] }\n];\n/** @nocollapse */\nAngularFireAnalyticsModule.ctorParameters = () => [\n    { type: AngularFireAnalytics },\n    { type: ScreenTrackingService, decorators: [{ type: Optional }] },\n    { type: UserTrackingService, decorators: [{ type: Optional }] }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { APP_NAME, APP_VERSION, AngularFireAnalytics, AngularFireAnalyticsModule, COLLECTION_ENABLED, CONFIG, DEBUG_MODE, ScreenTrackingService, UserTrackingService };\n"]}