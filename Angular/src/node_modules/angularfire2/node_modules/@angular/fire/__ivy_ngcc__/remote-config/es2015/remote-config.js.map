{"version":3,"sources":["D:/370/FinalFrontend/node_modules/angularfire2/node_modules/@angular/fire/remote-config/es2015/remote-config.js"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qIAwEE;sCACoC,AAEnC;;;;;;;;;;;;;;;;;;;;;;;;;;2DAKyB","file":"remote-config.js","sourcesContent":["var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { Injectable, Inject, Optional, NgZone, InjectionToken } from '@angular/core';\nimport { Observable, concat, of, pipe } from 'rxjs';\nimport { map, switchMap, tap, shareReplay, distinctUntilChanged, filter, groupBy, mergeMap, scan, withLatestFrom, startWith, debounceTime, observeOn } from 'rxjs/operators';\nimport { ɵlazySDKProxy, FIREBASE_OPTIONS, FIREBASE_APP_NAME } from '@angular/fire';\n;\nexport const SETTINGS = new InjectionToken('angularfire2.remoteConfig.settings');\nexport const DEFAULTS = new InjectionToken('angularfire2.remoteConfig.defaultConfig');\nimport { _firebaseAppFactory, ɵAngularFireSchedulers } from '@angular/fire';\n;\nexport class Value {\n    constructor(_source, _value) {\n        this._source = _source;\n        this._value = _value;\n    }\n    asBoolean() { return ['1', 'true', 't', 'y', 'yes', 'on'].indexOf(this._value.toLowerCase()) > -1; }\n    asString() { return this._value; }\n    asNumber() { return Number(this._value) || 0; }\n    getSource() { return this._source; }\n}\nexport class Parameter extends Value {\n    constructor(key, fetchTimeMillis, source, value) {\n        super(source, value);\n        this.key = key;\n        this.fetchTimeMillis = fetchTimeMillis;\n    }\n}\nconst filterTest = (fn) => filter(it => Array.isArray(it) ? it.some(fn) : fn(it));\nconst ɵ0 = filterTest;\nexport const filterRemote = () => filterTest(p => p.getSource() === 'remote');\nexport const filterFresh = (howRecentInMillis) => filterTest(p => p.fetchTimeMillis + howRecentInMillis >= new Date().getTime());\nlet AngularFireRemoteConfig = class AngularFireRemoteConfig {\n    constructor(options, nameOrConfig, settings, defaultConfig, zone) {\n        this.zone = zone;\n        const schedulers = new ɵAngularFireSchedulers(zone);\n        const remoteConfig$ = of(undefined).pipe(observeOn(schedulers.outsideAngular), switchMap(() => zone.runOutsideAngular(() => import('firebase/remote-config'))), map(() => _firebaseAppFactory(options, zone, nameOrConfig)), map(app => app.remoteConfig()), tap(rc => {\n            if (settings) {\n                rc.settings = settings;\n            }\n            if (defaultConfig) {\n                rc.defaultConfig = defaultConfig;\n            }\n        }), startWith(undefined), shareReplay({ bufferSize: 1, refCount: false }));\n        const loadedRemoteConfig$ = remoteConfig$.pipe(filter(rc => !!rc));\n        let default$ = of(Object.keys(defaultConfig || {}).reduce((c, k) => (Object.assign({}, c, { [k]: new Value(\"default\", defaultConfig[k].toString()) })), {}));\n        const filterOutDefaults = map(all => Object.keys(all)\n            .filter(key => all[key].getSource() != 'default')\n            .reduce((acc, key) => (Object.assign({}, acc, { [key]: all[key] })), {}));\n        const existing$ = loadedRemoteConfig$.pipe(switchMap(rc => rc.activate()\n            .then(() => rc.ensureInitialized())\n            .then(() => rc.getAll())), filterOutDefaults);\n        const fresh$ = loadedRemoteConfig$.pipe(switchMap(rc => zone.runOutsideAngular(() => rc.fetchAndActivate()\n            .then(() => rc.ensureInitialized())\n            .then(() => rc.getAll()))), filterOutDefaults);\n        this.parameters = concat(default$, existing$, fresh$).pipe(scanToParametersArray(remoteConfig$), shareReplay({ bufferSize: 1, refCount: true }));\n        this.changes = this.parameters.pipe(switchMap(params => of(...params)), groupBy(param => param.key), mergeMap(group => group.pipe(distinctUntilChanged())));\n        this.strings = proxyAll(this.parameters, 'strings');\n        this.booleans = proxyAll(this.parameters, 'booleans');\n        this.numbers = proxyAll(this.parameters, 'numbers');\n        return ɵlazySDKProxy(this, loadedRemoteConfig$, zone);\n    }\n};\nAngularFireRemoteConfig = __decorate([\n    Injectable(),\n    __param(0, Inject(FIREBASE_OPTIONS)),\n    __param(1, Optional()), __param(1, Inject(FIREBASE_APP_NAME)),\n    __param(2, Optional()), __param(2, Inject(SETTINGS)),\n    __param(3, Optional()), __param(3, Inject(DEFAULTS)),\n    __metadata(\"design:paramtypes\", [Object, Object, Object, Object, NgZone])\n], AngularFireRemoteConfig);\nexport { AngularFireRemoteConfig };\nconst scanToParametersArray = (remoteConfig) => pipe(withLatestFrom(remoteConfig), scan((existing, [all, rc]) => {\n    const allKeys = [...existing.map(p => p.key), ...Object.keys(all)].filter((v, i, a) => a.indexOf(v) === i);\n    return allKeys.map(key => {\n        const updatedValue = all[key];\n        return updatedValue ? new Parameter(key, rc ? rc.fetchTimeMillis : -1, updatedValue.getSource(), updatedValue.asString())\n            : existing.find(p => p.key === key);\n    });\n}, []));\nconst ɵ1 = scanToParametersArray;\nconst AS_TO_FN = { 'strings': 'asString', 'numbers': 'asNumber', 'booleans': 'asBoolean' };\nconst STATIC_VALUES = { 'numbers': 0, 'booleans': false, 'strings': undefined };\nexport const budget = (interval) => (source) => new Observable(observer => {\n    let timedOut = false;\n    const timeout = setTimeout(() => {\n        observer.complete();\n        timedOut = true;\n    }, interval);\n    return source.subscribe({\n        next(val) { if (!timedOut) {\n            observer.next(val);\n        } },\n        error(err) { if (!timedOut) {\n            clearTimeout(timeout);\n            observer.error(err);\n        } },\n        complete() { if (!timedOut) {\n            clearTimeout(timeout);\n            observer.complete();\n        } }\n    });\n});\nconst typedMethod = (it) => {\n    switch (typeof it) {\n        case 'string': return 'asString';\n        case 'boolean': return 'asBoolean';\n        case 'number': return 'asNumber';\n        default: return 'asString';\n    }\n};\nconst ɵ2 = typedMethod;\nexport function scanToObject(to = 'strings') {\n    return pipe(scan((c, p) => (Object.assign({}, c, { [p.key]: typeof to === 'object' ?\n            p[typedMethod(to[p.key])]() :\n            p[AS_TO_FN[to]]() })), typeof to === 'object' ?\n        to :\n        {}), debounceTime(1), budget(10), distinctUntilChanged((a, b) => JSON.stringify(a) === JSON.stringify(b)));\n}\n;\nexport function mapToObject(to = 'strings') {\n    return pipe(map((params) => params.reduce((c, p) => (Object.assign({}, c, { [p.key]: typeof to === 'object' ?\n            p[typedMethod(to[p.key])]() :\n            p[AS_TO_FN[to]]() })), typeof to === 'object' ?\n        to :\n        {})), distinctUntilChanged((a, b) => JSON.stringify(a) === JSON.stringify(b)));\n}\n;\nconst proxyAll = (observable, as) => new Proxy(observable.pipe(mapToObject(as)), {\n    get: (self, name) => self[name] || observable.pipe(map(all => all.find(p => p.key === name)), map(param => param ? param[AS_TO_FN[as]]() : STATIC_VALUES[as]), distinctUntilChanged())\n});\nconst ɵ3 = proxyAll;\nexport { ɵ0, ɵ1, ɵ2, ɵ3 };\n"]}