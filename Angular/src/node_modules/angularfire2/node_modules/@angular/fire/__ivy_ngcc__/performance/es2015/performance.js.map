{"version":3,"sources":["D:/370/FinalFrontend/node_modules/angularfire2/node_modules/@angular/fire/performance/es2015/performance.js"],"names":[],"mappings":";;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kIAkFE;qCACmC,AAElC;;;;;;;;;;;;;;;;;;;;;;;4FAKwB","file":"performance.js","sourcesContent":["var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { Injectable, NgZone, ApplicationRef, InjectionToken, Inject, Optional } from '@angular/core';\nimport { Observable, from } from 'rxjs';\nimport { first, tap, map, shareReplay, switchMap } from 'rxjs/operators';\nimport { FirebaseApp } from '@angular/fire';\nexport const AUTOMATICALLY_TRACE_CORE_NG_METRICS = new InjectionToken('angularfire2.performance.auto_trace');\nexport const INSTRUMENTATION_ENABLED = new InjectionToken('angularfire2.performance.instrumentationEnabled');\nexport const DATA_COLLECTION_ENABLED = new InjectionToken('angularfire2.performance.dataCollectionEnabled');\nlet AngularFirePerformance = class AngularFirePerformance {\n    constructor(app, automaticallyTraceCoreNgMetrics, instrumentationEnabled, dataCollectionEnabled, appRef, zone) {\n        this.zone = zone;\n        this.trace$ = (name, options) => this.performance.pipe(switchMap(performance => new Observable(emitter => this.zone.runOutsideAngular(() => {\n            const trace = performance.trace(name);\n            options && options.metrics && Object.keys(options.metrics).forEach(metric => {\n                trace.putMetric(metric, options.metrics[metric]);\n            });\n            options && options.attributes && Object.keys(options.attributes).forEach(attribute => {\n                trace.putAttribute(attribute, options.attributes[attribute]);\n            });\n            const attributeSubscriptions = options && options.attribute$ ? Object.keys(options.attribute$).map(attribute => options.attribute$[attribute].subscribe(next => trace.putAttribute(attribute, next))) : [];\n            const metricSubscriptions = options && options.metric$ ? Object.keys(options.metric$).map(metric => options.metric$[metric].subscribe(next => trace.putMetric(metric, next))) : [];\n            const incrementOnSubscriptions = options && options.incrementMetric$ ? Object.keys(options.incrementMetric$).map(metric => options.incrementMetric$[metric].subscribe(next => trace.incrementMetric(metric, next || undefined))) : [];\n            emitter.next(trace.start());\n            return { unsubscribe: () => {\n                    trace.stop();\n                    metricSubscriptions.forEach(m => m.unsubscribe());\n                    incrementOnSubscriptions.forEach(m => m.unsubscribe());\n                    attributeSubscriptions.forEach(m => m.unsubscribe());\n                } };\n        }))));\n        this.traceUntil = (name, test, options) => (source$) => new Observable(subscriber => {\n            const traceSubscription = this.trace$(name, options).subscribe();\n            return source$.pipe(tap(a => test(a) && traceSubscription.unsubscribe(), () => { }, () => options && options.orComplete && traceSubscription.unsubscribe())).subscribe(subscriber);\n        });\n        this.traceWhile = (name, test, options) => (source$) => new Observable(subscriber => {\n            let traceSubscription;\n            return source$.pipe(tap(a => {\n                if (test(a)) {\n                    traceSubscription = traceSubscription || this.trace$(name, options).subscribe();\n                }\n                else {\n                    traceSubscription && traceSubscription.unsubscribe();\n                    traceSubscription = undefined;\n                }\n            }, () => { }, () => options && options.orComplete && traceSubscription && traceSubscription.unsubscribe())).subscribe(subscriber);\n        });\n        this.traceUntilComplete = (name, options) => (source$) => new Observable(subscriber => {\n            const traceSubscription = this.trace$(name, options).subscribe();\n            return source$.pipe(tap(() => { }, () => { }, () => traceSubscription.unsubscribe())).subscribe(subscriber);\n        });\n        this.traceUntilFirst = (name, options) => (source$) => new Observable(subscriber => {\n            const traceSubscription = this.trace$(name, options).subscribe();\n            return source$.pipe(tap(() => traceSubscription.unsubscribe(), () => { }, () => { })).subscribe(subscriber);\n        });\n        this.trace = (name, options) => (source$) => new Observable(subscriber => {\n            const traceSubscription = this.trace$(name, options).subscribe();\n            return source$.pipe(tap(() => traceSubscription.unsubscribe(), () => { }, () => traceSubscription.unsubscribe())).subscribe(subscriber);\n        });\n        const requirePerformance = from(zone.runOutsideAngular(() => import('firebase/performance')));\n        this.performance = requirePerformance.pipe(map(() => zone.runOutsideAngular(() => app.performance())), tap(performance => {\n            if (instrumentationEnabled == false) {\n                performance.instrumentationEnabled = false;\n            }\n            if (dataCollectionEnabled == false) {\n                performance.dataCollectionEnabled = false;\n            }\n        }), shareReplay(1));\n        if (automaticallyTraceCoreNgMetrics != false) {\n            appRef.isStable.pipe(first(it => it), this.traceUntilComplete('isStable')).subscribe();\n        }\n    }\n};\nAngularFirePerformance = __decorate([\n    Injectable(),\n    __param(1, Optional()), __param(1, Inject(AUTOMATICALLY_TRACE_CORE_NG_METRICS)),\n    __param(2, Optional()), __param(2, Inject(INSTRUMENTATION_ENABLED)),\n    __param(3, Optional()), __param(3, Inject(DATA_COLLECTION_ENABLED)),\n    __metadata(\"design:paramtypes\", [FirebaseApp, Object, Object, Object, ApplicationRef,\n        NgZone])\n], AngularFirePerformance);\nexport { AngularFirePerformance };\n"]}