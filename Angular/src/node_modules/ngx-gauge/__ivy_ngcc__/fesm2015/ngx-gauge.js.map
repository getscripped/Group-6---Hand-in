{"version":3,"sources":["D:/370/Project code/gradus/node_modules/ngx-gauge/fesm2015/ngx-gauge.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;;;;;;;;;;;;;;;;;;;EAiBE,wIAMiB;;;;EAEjB,4IAMkB;;;;EAElB,oIAMgB;;;;EAEhB,oIAMgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;irBA+MhB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uBA0GqB,AAiBpB;;;;;;EAID;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BAOiB","file":"ngx-gauge.js","sourcesContent":["import { __decorate, __metadata } from 'tslib';\nimport { Directive, ElementRef, Renderer2, ViewChild, ContentChild, Input, Component, ViewEncapsulation, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\nfunction clamp(value, min, max) {\r\n    return Math.max(min, Math.min(max, value));\r\n}\r\nfunction coerceBooleanProperty(value) {\r\n    return value != null && `${value}` !== 'false';\r\n}\r\nfunction coerceNumberProperty(value, fallbackValue = 0) {\r\n    return isNaN(parseFloat(value)) || isNaN(Number(value)) ? fallbackValue : Number(value);\r\n}\r\nfunction cssUnit(value) {\r\n    return `${value}px`;\r\n}\r\nfunction isNumber(value) {\r\n    return value != undefined && !isNaN(parseFloat(value)) && !isNaN(Number(value));\r\n}\n\nlet NgxGaugeAppend = class NgxGaugeAppend {\r\n};\r\nNgxGaugeAppend = __decorate([\r\n    Directive({\r\n        selector: \"ngx-gauge-append\",\r\n        exportAs: \"ngxGaugeAppend\"\r\n    })\r\n], NgxGaugeAppend);\r\nlet NgxGaugePrepend = class NgxGaugePrepend {\r\n};\r\nNgxGaugePrepend = __decorate([\r\n    Directive({\r\n        selector: \"ngx-gauge-prepend\",\r\n        exportAs: \"ngxGaugePrepend\"\r\n    })\r\n], NgxGaugePrepend);\r\nlet NgxGaugeValue = class NgxGaugeValue {\r\n};\r\nNgxGaugeValue = __decorate([\r\n    Directive({\r\n        selector: \"ngx-gauge-value\",\r\n        exportAs: \"ngxGaugeValue\"\r\n    })\r\n], NgxGaugeValue);\r\nlet NgxGaugeLabel = class NgxGaugeLabel {\r\n};\r\nNgxGaugeLabel = __decorate([\r\n    Directive({\r\n        selector: \"ngx-gauge-label\",\r\n        exportAs: \"ngxGaugeLabel\"\r\n    })\r\n], NgxGaugeLabel);\n\nconst DEFAULTS = {\r\n    MIN: 0,\r\n    MAX: 100,\r\n    TYPE: 'arch',\r\n    THICK: 4,\r\n    FOREGROUND_COLOR: 'rgba(0, 150, 136, 1)',\r\n    BACKGROUND_COLOR: 'rgba(0, 0, 0, 0.1)',\r\n    CAP: 'butt',\r\n    SIZE: 200\r\n};\r\nlet NgxGauge = class NgxGauge {\r\n    constructor(_elementRef, _renderer) {\r\n        this._elementRef = _elementRef;\r\n        this._renderer = _renderer;\r\n        this._size = DEFAULTS.SIZE;\r\n        this._min = DEFAULTS.MIN;\r\n        this._max = DEFAULTS.MAX;\r\n        this._animate = true;\r\n        this._initialized = false;\r\n        this._animationRequestID = 0;\r\n        this.ariaLabel = '';\r\n        this.ariaLabelledby = null;\r\n        this.type = DEFAULTS.TYPE;\r\n        this.cap = DEFAULTS.CAP;\r\n        this.thick = DEFAULTS.THICK;\r\n        this.foregroundColor = DEFAULTS.FOREGROUND_COLOR;\r\n        this.backgroundColor = DEFAULTS.BACKGROUND_COLOR;\r\n        this.thresholds = Object.create(null);\r\n        this._value = 0;\r\n        this.duration = 1200;\r\n    }\r\n    get size() { return this._size; }\r\n    set size(value) {\r\n        this._size = coerceNumberProperty(value);\r\n    }\r\n    get min() { return this._min; }\r\n    set min(value) {\r\n        this._min = coerceNumberProperty(value, DEFAULTS.MIN);\r\n    }\r\n    get animate() { return this._animate; }\r\n    set animate(value) {\r\n        this._animate = coerceBooleanProperty(value);\r\n    }\r\n    get max() { return this._max; }\r\n    set max(value) {\r\n        this._max = coerceNumberProperty(value, DEFAULTS.MAX);\r\n    }\r\n    get value() { return this._value; }\r\n    set value(val) {\r\n        this._value = coerceNumberProperty(val);\r\n    }\r\n    ngOnChanges(changes) {\r\n        const isCanvasPropertyChanged = changes['thick'] || changes['type'] || changes['cap'] || changes['size'];\r\n        const isDataChanged = changes['value'] || changes['min'] || changes['max'];\r\n        if (this._initialized) {\r\n            if (isDataChanged) {\r\n                let nv, ov;\r\n                if (changes['value']) {\r\n                    nv = changes['value'].currentValue;\r\n                    ov = changes['value'].previousValue;\r\n                }\r\n                this._update(nv, ov);\r\n            }\r\n            if (isCanvasPropertyChanged) {\r\n                this._destroy();\r\n                this._init();\r\n            }\r\n        }\r\n    }\r\n    _updateSize() {\r\n        this._renderer.setStyle(this._elementRef.nativeElement, 'width', cssUnit(this._getWidth()));\r\n        this._renderer.setStyle(this._elementRef.nativeElement, 'height', cssUnit(this._getCanvasHeight()));\r\n        this._canvas.nativeElement.width = this._getWidth();\r\n        this._canvas.nativeElement.height = this._getCanvasHeight();\r\n        this._renderer.setStyle(this._label.nativeElement, 'transform', 'translateY(' + (this.size / 3 * 2 - this.size / 13 / 4) + 'px)');\r\n        this._renderer.setStyle(this._reading.nativeElement, 'transform', 'translateY(' + (this.size / 2 - this.size * 0.22 / 2) + 'px)');\r\n    }\r\n    ngAfterViewInit() {\r\n        if (this._canvas) {\r\n            this._init();\r\n        }\r\n    }\r\n    ngOnDestroy() {\r\n        this._destroy();\r\n    }\r\n    _getBounds(type) {\r\n        let head, tail;\r\n        if (type == 'semi') {\r\n            head = Math.PI;\r\n            tail = 2 * Math.PI;\r\n        }\r\n        else if (type == 'full') {\r\n            head = 1.5 * Math.PI;\r\n            tail = 3.5 * Math.PI;\r\n        }\r\n        else if (type === 'arch') {\r\n            head = 0.8 * Math.PI;\r\n            tail = 2.2 * Math.PI;\r\n        }\r\n        return { head, tail };\r\n    }\r\n    _drawShell(start, middle, tail, color) {\r\n        let center = this._getCenter(), radius = this._getRadius();\r\n        middle = Math.max(middle, start); // never below 0%\r\n        middle = Math.min(middle, tail); // never exceed 100%\r\n        if (this._initialized) {\r\n            this._clear();\r\n            this._context.beginPath();\r\n            this._context.strokeStyle = this.backgroundColor;\r\n            this._context.arc(center.x, center.y, radius, middle, tail, false);\r\n            this._context.stroke();\r\n            this._context.beginPath();\r\n            this._context.strokeStyle = color;\r\n            this._context.arc(center.x, center.y, radius, start, middle, false);\r\n            this._context.stroke();\r\n        }\r\n    }\r\n    _clear() {\r\n        this._context.clearRect(0, 0, this._getWidth(), this._getHeight());\r\n    }\r\n    _getWidth() {\r\n        return this.size;\r\n    }\r\n    _getHeight() {\r\n        return this.size;\r\n    }\r\n    // canvas height will be shorter for type 'semi' and 'arch'\r\n    _getCanvasHeight() {\r\n        return (this.type == 'arch' || this.type == 'semi')\r\n            ? 0.85 * this._getHeight()\r\n            : this._getHeight();\r\n    }\r\n    _getRadius() {\r\n        var center = this._getCenter();\r\n        return center.x - this.thick;\r\n    }\r\n    _getCenter() {\r\n        var x = this._getWidth() / 2, y = this._getHeight() / 2;\r\n        return { x, y };\r\n    }\r\n    _init() {\r\n        this._context = this._canvas.nativeElement.getContext('2d');\r\n        this._initialized = true;\r\n        this._updateSize();\r\n        this._setupStyles();\r\n        this._create();\r\n    }\r\n    _destroy() {\r\n        if (this._animationRequestID) {\r\n            window.cancelAnimationFrame(this._animationRequestID);\r\n            this._animationRequestID = 0;\r\n        }\r\n        this._clear();\r\n        this._context = null;\r\n        this._initialized = false;\r\n    }\r\n    _setupStyles() {\r\n        this._context.lineCap = this.cap;\r\n        this._context.lineWidth = this.thick;\r\n    }\r\n    _getForegroundColorByRange(value) {\r\n        const match = Object.keys(this.thresholds)\r\n            .filter(function (item) { return isNumber(item) && Number(item) <= value; })\r\n            .sort((a, b) => Number(a) - Number(b))\r\n            .reverse()[0];\r\n        return match !== undefined\r\n            ? this.thresholds[match].color || this.foregroundColor\r\n            : this.foregroundColor;\r\n    }\r\n    _create(nv, ov) {\r\n        let self = this, type = this.type, bounds = this._getBounds(type), duration = this.duration, min = this.min, max = this.max, value = clamp(this.value, this.min, this.max), start = bounds.head, unit = (bounds.tail - bounds.head) / (max - min), displacement = unit * (value - min), tail = bounds.tail, color = this._getForegroundColorByRange(value), startTime;\r\n        if (self._animationRequestID) {\r\n            window.cancelAnimationFrame(self._animationRequestID);\r\n        }\r\n        function animate(timestamp) {\r\n            timestamp = timestamp || new Date().getTime();\r\n            let runtime = timestamp - startTime;\r\n            let progress = Math.min(runtime / duration, 1);\r\n            let previousProgress = ov ? (ov - min) * unit : 0;\r\n            let middle = start + previousProgress + displacement * progress;\r\n            self._drawShell(start, middle, tail, color);\r\n            if (self._animationRequestID && (runtime < duration)) {\r\n                self._animationRequestID = window.requestAnimationFrame((timestamp) => animate(timestamp));\r\n            }\r\n            else {\r\n                window.cancelAnimationFrame(self._animationRequestID);\r\n            }\r\n        }\r\n        if (this._animate) {\r\n            if (nv != undefined && ov != undefined) {\r\n                displacement = unit * nv - unit * ov;\r\n            }\r\n            self._animationRequestID = window.requestAnimationFrame((timestamp) => {\r\n                startTime = timestamp || new Date().getTime();\r\n                animate(startTime);\r\n            });\r\n        }\r\n        else {\r\n            self._drawShell(start, start + displacement, tail, color);\r\n        }\r\n    }\r\n    _update(nv, ov) {\r\n        this._clear();\r\n        this._create(nv, ov);\r\n    }\r\n};\r\nNgxGauge.ctorParameters = () => [\r\n    { type: ElementRef },\r\n    { type: Renderer2 }\r\n];\r\n__decorate([\r\n    ViewChild('canvas', { static: true }),\r\n    __metadata(\"design:type\", ElementRef)\r\n], NgxGauge.prototype, \"_canvas\", void 0);\r\n__decorate([\r\n    ViewChild('rLabel', { static: true }),\r\n    __metadata(\"design:type\", ElementRef)\r\n], NgxGauge.prototype, \"_label\", void 0);\r\n__decorate([\r\n    ViewChild('reading', { static: true }),\r\n    __metadata(\"design:type\", ElementRef)\r\n], NgxGauge.prototype, \"_reading\", void 0);\r\n__decorate([\r\n    ContentChild(NgxGaugeLabel),\r\n    __metadata(\"design:type\", NgxGaugeLabel)\r\n], NgxGauge.prototype, \"_labelChild\", void 0);\r\n__decorate([\r\n    ContentChild(NgxGaugePrepend),\r\n    __metadata(\"design:type\", NgxGaugePrepend)\r\n], NgxGauge.prototype, \"_prependChild\", void 0);\r\n__decorate([\r\n    ContentChild(NgxGaugeAppend),\r\n    __metadata(\"design:type\", NgxGaugeAppend)\r\n], NgxGauge.prototype, \"_appendChild\", void 0);\r\n__decorate([\r\n    ContentChild(NgxGaugeValue),\r\n    __metadata(\"design:type\", NgxGaugeValue)\r\n], NgxGauge.prototype, \"_valueDisplayChild\", void 0);\r\n__decorate([\r\n    Input('aria-label'),\r\n    __metadata(\"design:type\", String)\r\n], NgxGauge.prototype, \"ariaLabel\", void 0);\r\n__decorate([\r\n    Input('aria-labelledby'),\r\n    __metadata(\"design:type\", String)\r\n], NgxGauge.prototype, \"ariaLabelledby\", void 0);\r\n__decorate([\r\n    Input(),\r\n    __metadata(\"design:type\", Number),\r\n    __metadata(\"design:paramtypes\", [Number])\r\n], NgxGauge.prototype, \"size\", null);\r\n__decorate([\r\n    Input(),\r\n    __metadata(\"design:type\", Number),\r\n    __metadata(\"design:paramtypes\", [Number])\r\n], NgxGauge.prototype, \"min\", null);\r\n__decorate([\r\n    Input(),\r\n    __metadata(\"design:type\", Boolean),\r\n    __metadata(\"design:paramtypes\", [Object])\r\n], NgxGauge.prototype, \"animate\", null);\r\n__decorate([\r\n    Input(),\r\n    __metadata(\"design:type\", Number),\r\n    __metadata(\"design:paramtypes\", [Number])\r\n], NgxGauge.prototype, \"max\", null);\r\n__decorate([\r\n    Input(),\r\n    __metadata(\"design:type\", String)\r\n], NgxGauge.prototype, \"type\", void 0);\r\n__decorate([\r\n    Input(),\r\n    __metadata(\"design:type\", String)\r\n], NgxGauge.prototype, \"cap\", void 0);\r\n__decorate([\r\n    Input(),\r\n    __metadata(\"design:type\", Number)\r\n], NgxGauge.prototype, \"thick\", void 0);\r\n__decorate([\r\n    Input(),\r\n    __metadata(\"design:type\", String)\r\n], NgxGauge.prototype, \"label\", void 0);\r\n__decorate([\r\n    Input(),\r\n    __metadata(\"design:type\", String)\r\n], NgxGauge.prototype, \"append\", void 0);\r\n__decorate([\r\n    Input(),\r\n    __metadata(\"design:type\", String)\r\n], NgxGauge.prototype, \"prepend\", void 0);\r\n__decorate([\r\n    Input(),\r\n    __metadata(\"design:type\", String)\r\n], NgxGauge.prototype, \"foregroundColor\", void 0);\r\n__decorate([\r\n    Input(),\r\n    __metadata(\"design:type\", String)\r\n], NgxGauge.prototype, \"backgroundColor\", void 0);\r\n__decorate([\r\n    Input(),\r\n    __metadata(\"design:type\", Object)\r\n], NgxGauge.prototype, \"thresholds\", void 0);\r\n__decorate([\r\n    Input(),\r\n    __metadata(\"design:type\", Number),\r\n    __metadata(\"design:paramtypes\", [Number])\r\n], NgxGauge.prototype, \"value\", null);\r\n__decorate([\r\n    Input(),\r\n    __metadata(\"design:type\", Number)\r\n], NgxGauge.prototype, \"duration\", void 0);\r\nNgxGauge = __decorate([\r\n    Component({\r\n        selector: 'ngx-gauge',\r\n        template: \"<div class=\\\"reading-block\\\" #reading [style.fontSize]=\\\"size * 0.22 + 'px'\\\">\\r\\n  <!-- This block can not be indented correctly, because line breaks cause layout spacing, related problem: https://pt.stackoverflow.com/q/276760/2998 -->\\r\\n  <u class=\\\"reading-affix\\\" [ngSwitch]=\\\"_prependChild != null\\\"><ng-content select=\\\"ngx-gauge-prepend\\\" *ngSwitchCase=\\\"true\\\"></ng-content><ng-container *ngSwitchCase=\\\"false\\\">{{prepend}}</ng-container></u><ng-container [ngSwitch]=\\\"_valueDisplayChild != null\\\"><ng-content *ngSwitchCase=\\\"true\\\" select=\\\"ngx-gauge-value\\\"></ng-content><ng-container *ngSwitchCase=\\\"false\\\">{{value | number}}</ng-container></ng-container><u class=\\\"reading-affix\\\" [ngSwitch]=\\\"_appendChild != null\\\"><ng-content select=\\\"ngx-gauge-append\\\" *ngSwitchCase=\\\"true\\\"></ng-content><ng-container *ngSwitchCase=\\\"false\\\">{{append}}</ng-container></u>\\r\\n</div>\\r\\n<div class=\\\"reading-label\\\" #rLabel\\r\\n     [style.fontSize]=\\\"size / 13 + 'px'\\\"\\r\\n     [ngSwitch]=\\\"_labelChild != null\\\">\\r\\n  <ng-content select=\\\"ngx-gauge-label\\\" *ngSwitchCase=\\\"true\\\"></ng-content>\\r\\n  <ng-container *ngSwitchCase=\\\"false\\\">{{label}}</ng-container>\\r\\n</div>\\r\\n<canvas #canvas></canvas>\\r\\n\",\r\n        host: {\r\n            'role': 'slider',\r\n            'aria-readonly': 'true',\r\n            '[class.ngx-gauge-meter]': 'true',\r\n            '[attr.aria-valuemin]': 'min',\r\n            '[attr.aria-valuemax]': 'max',\r\n            '[attr.aria-valuenow]': 'value',\r\n            '[attr.aria-label]': 'ariaLabel',\r\n            '[attr.aria-labelledby]': 'ariaLabelledby'\r\n        },\r\n        encapsulation: ViewEncapsulation.None,\r\n        styles: [\".ngx-gauge-meter{display:inline-block;text-align:center;position:relative}.reading-block{position:absolute;width:100%;font-weight:400;white-space:nowrap;text-align:center;overflow:hidden;text-overflow:ellipsis}.reading-label{font-family:inherit;width:100%;display:inline-block;position:absolute;text-align:center;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-weight:400}.reading-affix{text-decoration:none;font-size:.6em;opacity:.8;font-weight:200;padding:0 .18em}.reading-affix:first-child{padding-left:0}.reading-affix:last-child{padding-right:0}\"]\r\n    }),\r\n    __metadata(\"design:paramtypes\", [ElementRef, Renderer2])\r\n], NgxGauge);\n\nlet NgxGaugeModule = class NgxGaugeModule {\r\n};\r\nNgxGaugeModule = __decorate([\r\n    NgModule({\r\n        imports: [CommonModule],\r\n        declarations: [NgxGauge, NgxGaugeAppend, NgxGaugePrepend, NgxGaugeValue, NgxGaugeLabel],\r\n        exports: [NgxGauge, NgxGaugeAppend, NgxGaugePrepend, NgxGaugeValue, NgxGaugeLabel]\r\n    })\r\n], NgxGaugeModule);\n\n/*\r\n * Public APIs of ngx-gauge\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { NgxGaugeModule, NgxGauge as ɵa, NgxGaugeAppend as ɵb, NgxGaugePrepend as ɵc, NgxGaugeValue as ɵd, NgxGaugeLabel as ɵe };\n"]}